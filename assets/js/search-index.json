[
  {
    "title": "Préface",
    "url": "/book/00-preface/",
    "text": "Préface Vitte est né d’un constat simple : la puissance sans lisibilité coûte cher. À mesure que les systèmes grandissent, les raccourcis deviennent des dettes, et les dettes deviennent des pannes. Ce livre s’adresse à celles et ceux qui veulent construire des logiciels proches de la machine sans renoncer à la clarté. Un langage n’est pas un dogme, c’est un outil. Vitte a été pensé comme un outil que l’on peut confier à une équipe entière sans se demander, trois mois plus tard, « qu’est-ce que ça veut dire ? ». C’est un langage qui préfère le concret aux tours de magie, et la lisibilité aux surprises. Si vous avez déjà passé une nuit à chercher un bug d’alignement mémoire, ou si vous avez relu un code performant mais incompréhensible, vous savez pourquoi ce livre existe. Notre objectif est simple : écrire du code qui fonctionne aujourd’hui, et qui reste compréhensible demain. Ce livre suit un fil conducteur O’Reilly : partir des fondations, enrichir progressivement la boîte à outils, puis construire des projets complets. Chaque chapitre apporte une idée, une pratique, et un exemple utilisable. Vous n’avez pas besoin de tout lire d’un trait. Vitte est un langage de travail ; ce livre est un compagnon de travail. Vous verrez revenir un même fil rouge : écrire un petit outil fiable, puis l’étendre jusqu’à un projet complet. À chaque étape, nous garderons le même souci : un code que l’on peut relire, expliquer, et maintenir."
  },
  {
    "title": "Avant-propos",
    "url": "/book/00-avant-propos/",
    "text": "Avant-propos À qui s’adresse ce livre Ce livre vise les développeurs et développeuses qui aiment comprendre ce que fait leur code et pourquoi il le fait. Si vous avez déjà utilisé C ou C++, si vous aimez les outils système, ou si vous voulez apprendre un langage bas niveau moderne sans céder à la complexité gratuite, vous êtes au bon endroit. Ce que vous allez apprendre Vous apprendrez à configurer un projet Vitte, à écrire du code clair et testable, à utiliser la bibliothèque standard, et à produire des binaires reproductibles. Vous verrez aussi comment la compilation fonctionne, ce qui aide énormément quand on débogue un projet réel. Comment lire ce livre Lisez les chapitres 1 à 4 pour démarrer rapidement. Sautez ensuite vers les chapitres qui correspondent à votre besoin immédiat. Revenez aux projets complets quand vous avez besoin d’un exemple de bout en bout. Conventions Les exemples sont courts et commentés. La syntaxe Vitte évolue encore ; quand elle est volontairement indicative, je le précise. Les chapitres d’annexes complètent les détails formels. Remerciements Un langage n’est jamais l’œuvre d’une seule personne. Les retours de la communauté, même les plus critiques, ont façonné Vitte. Merci à celles et ceux qui ont préféré la clarté à la facilité, et qui ont pris le temps d’expliquer un bug au lieu de le contourner."
  },
  {
    "title": "1. Démarrer",
    "url": "/book/01-demarrer/",
    "text": "1. Démarrer Ce chapitre est votre premier contact avec Vitte. L’objectif est simple : installer l’outil, lancer un build, comprendre la boucle de feedback, et savoir où regarder quand quelque chose ne marche pas. Nous ne cherchons pas la perfection, seulement une trajectoire qui vous permette d’avancer vite et proprement. L’idée O’Reilly ici est claire : vous donner un terrain sûr et reproductible. Si vous gardez ce chapitre sous la main, vous pouvez toujours revenir à un état stable. Installation rapide Le binaire est disponible dans . Gardez cette commande en tête : si tout échoue, repartez d’un binaire propre. La règle d’or : ne déboguez jamais un outil que vous n’avez pas construit vous‑même. Vérifier l’environnement Le diagnostic doit être court et clair. S’il échoue, corrigez l’environnement avant de toucher au code. Beaucoup de problèmes « mystérieux » viennent d’une dépendance mal installée. Un compilateur est un écosystème, pas un exécutable isolé. Votre premier build La première compilation est un petit rituel : elle vous rappelle que le langage existe sur votre machine, et que la boucle outil → code → binaire est bien en place. N’essayez pas de comprendre tout le code d’exemple ; utilisez‑le comme un test de santé. Lire un diagnostic Les codes d’erreur sont stables. Apprenez à les lire comme des balises : ils vous diront quoi chercher dans la doc ou dans le code du compilateur. Un code d’erreur bien choisi est une indexation du savoir. La boucle de feedback Le secret d’une progression rapide est une boucle courte : Écrire un petit changement. Lancer un check rapide. Lire l’erreur comme un guide. Corriger, puis recommencer. C’est une discipline simple, mais elle transforme la productivité à long terme. Un compilateur qui donne un retour rapide est un multiplicateur de qualité. Quand ça casse Quand tout semble cassé, revenez aux fondamentaux : Rebuild complet. Exemple minimal dans un seul fichier. Reproduire le problème sans logique superflue. Cette méthode est l’outil numéro un pour comprendre un langage émergent. Vous n’avez pas besoin d’être ingénieur compilateur : vous avez besoin d’isoler un fait. Règles simples pour bien commencer Gardez les exemples courts. Utilisez pour valider sans compiler. Lisez les codes d’erreur, pas seulement le message. Si un test échoue, réduisez le problème à un fichier et un cas minimal. Fil rouge : un mini‑outil Nous reviendrons souvent à un petit outil en ligne de commande. L’idée est d’avoir un terrain stable pour tester vos nouvelles connaissances sans tout réécrire. Cette continuité vous permet de comparer vos décisions à travers les chapitres : « est‑ce que mon code est plus clair qu’avant ? ». Exercice : votre premier binaire propre Créez un fichier avec une fonction minimale. Lancez puis . Introduisez volontairement une erreur de type et lisez le diagnostic. Corrigez l’erreur et relancez le build. Le but n’est pas d’apprendre une syntaxe, mais d’apprendre un cycle. À retenir Apprendre Vitte, c’est apprendre une méthode de travail. Le langage vous aidera, mais la discipline de lecture, d’isolation, et de tests est ce qui fera la vraie différence. Exemple guidé : un programme qui échoue bien Écrivez un programme qui ouvre un fichier, puis échouez volontairement. Le but est d’apprendre à produire un message clair. Écrivez une version qui échoue avec un message pauvre. Améliorez le message avec le nom du fichier et l’action tentée. Ajoutez un code d’erreur stable (ou un enum interne). Ce petit exercice vous apprend que « bien échouer » est une compétence, pas une conséquence. Pièges classiques de débutant Confondre et et perdre du temps inutile. Modifier plusieurs fichiers à la fois, puis ne plus savoir ce qui a cassé. Lancer des builds longs alors qu’un check rapide aurait suffi. Checklist de démarrage Le compilateur se construit localement. retourne un statut propre. Le premier build réussit. Vous savez lire un diagnostic. Exercice long Créez un petit outil qui : Lit un argument . Affiche « Bonjour <name> ». Échoue proprement si l’argument est absent. Le but n’est pas l’outil, mais la discipline : interface claire, erreurs claires, test simple. Étude de cas : diagnostic minimal Vous compilez un fichier, et le compilateur affiche un diagnostic. Voici une méthode systématique : Lisez le code d’erreur. Lisez la ligne indiquée. Supprimez tout le code non essentiel. Reproduisez l’erreur dans un fichier minimal. Cette méthode est plus rapide que “deviner”. Elle vous force à transformer une émotion (“ça ne marche pas”) en un fait (“cette ligne provoque cette erreur”). Exercice long : projet « hello‑vitte » Objectif : écrire un programme qui lit un argument et affiche un message. Écrire un parser d’arguments minimal. Ajouter . Retourner un code d’erreur si est absent. Écrire un test manuel (exécuter avec et sans argument). Ce projet est volontairement simple : il vous apprend la discipline de la boucle courte. Code complet (API actuelle) API idéale (future) Un module pourrait générer automatiquement et valider les arguments déclaratifs."
  },
  {
    "title": "2. Philosophie et design",
    "url": "/book/02-philosophie/",
    "text": "2. Philosophie et design Un langage bas niveau doit faire deux choses : ne pas vous mentir et ne pas vous surprendre. Vitte a été pensé autour de cette idée. C’est un langage qui préfère la clarté à la magie, et la stabilité à la nouveauté permanente. Principes Clarté par défaut : le code doit se lire comme un contrat. Diagnostics précis : les messages d’erreur doivent aider, pas juger. Pipeline transparent : comprendre la compilation doit être possible sans lire 100 000 lignes de code. Reproductibilité : un build doit être un résultat, pas une loterie. Ces principes ne sont pas décoratifs. Ils influencent la syntaxe, les messages d’erreur, et même la manière dont on organise les modules. Le coût des abstractions Les abstractions sont utiles, mais elles ont un coût. Vitte vous demande d’être explicite sur ce coût. Cela rend le code plus verbeux au début, mais il devient plus robuste quand l’équipe grandit. Un code court mais incompréhensible est une victoire de dix minutes ; un code clair est une victoire de dix ans. Ce que Vitte n’est pas Un langage « magique ». Un macro‑système sans garde‑fous. Un système qui cache l’ABI ou les appels externes. Cette position peut sembler austère au début. Mais elle paie vite quand le projet grandit. Le rôle du compilateur Le compilateur n’est pas un oracle. Il est un partenaire : il vous signale les incohérences, il refuse les ambiguïtés, et il vous aide à rester honnête. Cette relation est saine : elle vous pousse à expliciter vos hypothèses. La stabilité comme stratégie Les projets long‑vivants demandent un langage qui ne change pas à chaque mode. La stabilité n’est pas un conservatisme, c’est une stratégie : elle réduit les coûts de maintenance et rend le code plus abordable pour les nouvelles recrues. Lisibilité et performance ne sont pas des ennemies Un code lisible ne signifie pas un code lent. Au contraire : la lisibilité vous permet d’identifier les vrais chemins chauds, et donc d’optimiser là où c’est utile. Le code obscur, lui, dissipe vos efforts. Le contrat implicite Vitte vous demande d’être explicite, mais en échange il promet quelque chose : un contrat stable, des diagnostics cohérents, et un pipeline compréhensible. C’est un pacte entre le langage et le développeur. À retenir Le design de Vitte privilégie la durabilité du code. Si vous hésitez entre « court » et « clair », choisissez « clair ». Deux styles de code Comparez ces deux styles : Style A : court, dense, difficile à lire. Style B : plus long, mais chaque étape est visible. Un compilateur accepte les deux. Une équipe, elle, préfère le second. La lisibilité est un acte collectif. Pourquoi la simplicité est une stratégie Quand un bug survient, vous n’avez pas besoin d’une théorie. Vous avez besoin d’une trace lisible. La simplicité augmente la probabilité que votre futur vous comprenne. Erreurs courantes de philosophie Confondre “minimal” et “opaque”. Penser que la syntaxe magique accélère les équipes. Sacrifier la lisibilité pour une optimisation non mesurée. Checklist de design Chaque module a une responsabilité claire. Les interfaces sont petites et bien nommées. Les erreurs sont actionnables. Le build est reproductible. Exercice : écrire pour un autre Prenez un petit bout de code que vous connaissez bien. Réécrivez‑le comme si vous deviez l’expliquer à une personne qui ne connaît pas votre projet. Si votre code devient plus clair, vous avez compris la philosophie. O’Reilly en une phrase Un langage est une promesse d’explications futures. Vitte vous demande d’être explicite aujourd’hui pour éviter l’opacité demain. Code complet (API actuelle) Exemple de deux styles : l’un compact, l’autre lisible. API idéale (future) Un formalisme de style (lint) qui encourage les blocs lisibles au lieu des expressions compressées."
  },
  {
    "title": "3. Anatomie d’un projet",
    "url": "/book/03-projet/",
    "text": "3. Anatomie d’un projet Dans ce chapitre, on définit une structure de projet simple, claire, et reproductible. Un projet Vitte doit être lisible en un seul coup d’œil. La structure ne doit pas être décorative : elle doit permettre à un nouveau contributeur de comprendre où est le cœur du code en moins de cinq minutes. Structure minimale pour le code. pour les tests. pour les commandes de build. Le choix n’est pas unique, mais l’important est la cohérence et la simplicité. Un fichier principal Un programme exécutable commence par une entrée claire : C’est la première ligne de contrat entre votre code et la plateforme. Des modules clairs Organisez votre code en modules qui ont chacun un rôle net. Si un module commence à tout faire, c’est un signal pour le scinder. La modularité n’est pas une règle esthétique : c’est une méthode pour limiter la propagation des erreurs. Une dépendance est une décision Quand vous ajoutez un module, vous ajoutez aussi une surface de maintenance. Posez toujours la question : « cet ajout simplifie‑t‑il l’ensemble ? » Si la réponse est non, vous êtes en train de payer la dette d’une abstraction. Construire un pipeline local L’objectif est de pouvoir : Lancer un check rapide. Compiler en mode debug. Compiler en mode release. Un Makefile simple fait déjà beaucoup. On le détaillera plus loin dans le livre. Les chemins de build Séparez ce qui est temporaire de ce qui est durable. Les artefacts de build ne doivent pas polluer le code source. Un projet propre est un projet qui se nettoie facilement. Le coût d’un mauvais projet Une structure confuse ralentit les diagnostics et décourage les contributions. Prenez ce temps au début, vous le récupérerez en fin de sprint. Exercice : refactorer un projet minimal Créez un dossier et un fichier . Ajoutez un module dans . Déplacez la logique d’entrée/sortie dans ce module. Vérifiez que l’interface reste claire. À retenir Un projet Vitte bien organisé est un projet qui se débogue facilement. Exemple de Makefile minimal Un Makefile n’a pas besoin d’être complexe. Trois cibles suffisent : , , . La valeur est dans la constance. Erreurs courantes de structure Mettre tout dans . Mélanger tests et code de production. Avoir un qui cache la logique au lieu de la rendre visible. Checklist projet Les dossiers ont un rôle clair. Le point d’entrée est facile à trouver. Les tests sont dans un dossier dédié. Le build ne pollue pas la racine. Exemple filé Imaginez un outil qui lit un fichier, filtre des lignes, et affiche un résumé. contient l’entrée. contient la logique de parsing. contient l’affichage. contient un échantillon et un test de non‑régression. Ce découpage vous donne un “plan de ville”. Sans plan, vous vous perdez. Code complet (API actuelle) Structure minimale de projet : . . . Exemple d’entrée : API idéale (future) Un fichier manifeste ( ) pourrait décrire le projet, les cibles, et les flags."
  },
  {
    "title": "4. Syntaxe de base",
    "url": "/book/04-syntaxe/",
    "text": "4. Syntaxe de base La syntaxe de Vitte est volontairement sobre. Elle évite les surprises et favorise les formes régulières. Si vous venez de C, vous reconnaîtrez des formes familières, sans les angles morts historiques. Valeurs et expressions Les expressions sont directes : vous lisez ce que la machine exécutera. Le style recommandé est d’écrire des expressions courtes, puis de les nommer. Blocs et portée Les blocs définissent la portée des noms. Si vous réutilisez un identifiant, faites‑le consciemment et localement ; les variables globales sont une dette à long terme. Indentation et lisibilité Vous écrivez pour la machine, mais aussi pour un futur lecteur. L’indentation cohérente, les lignes courtes, et les noms précis sont des optimisations humaines. Commentaires Les commentaires sont là pour expliquer une intention, pas pour répéter le code. Un bon commentaire répond à « pourquoi ? ». Style minimal Un bon code Vitte n’est pas forcément « court », mais il est souvent « plat ». Évitez les cascades de conditions, les expressions trop imbriquées, et les effets cachés. Densité de lecture Un lecteur humain n’a pas la patience d’un compilateur. Si un bloc demande plus d’une respiration pour être compris, il est peut‑être trop dense. Découper est un acte de respect. À retenir Une syntaxe courte vaut mieux qu’une syntaxe clever. Nommez tôt, testez tôt, refactorez tôt. La lisibilité est une performance à long terme. Exemple long : du code lisible Prenez un bloc trop dense, puis découpez‑le. Le but est d’apprendre à réduire la charge cognitive. Avant : une expression longue, imbriquée. Après : trois lignes avec des noms clairs. Erreurs courantes Utiliser des noms courts pour des concepts longs. Mélanger déclaration et logique dans la même ligne. Empiler plusieurs effets dans une seule expression. Checklist de lisibilité Une ligne, une idée. Chaque variable a un nom lisible. Les blocs ne dépassent pas une taille raisonnable. Exercice : rendre lisible Prenez une fonction avec trois imbriqués et refactorez‑la en retours précoces. Comparez les deux versions. La version lisible est souvent plus courte, mais surtout plus honnête. Code complet (API actuelle) API idéale (future) Des conventions standardisées pour les blocs et les guard‑clauses."
  },
  {
    "title": "5. Types et valeurs",
    "url": "/book/05-types/",
    "text": "5. Types et valeurs Les types sont une forme de documentation exécutable. Dans Vitte, ils servent à exprimer vos contraintes, pas à vous piéger. Un bon type est une phrase courte : il dit ce que la valeur est, pas seulement ce qu’elle contient. Types numériques On retrouve des types entiers classiques ( , ) et des flottants. Le but est d’être explicite sur la taille et le signe. Ce détail est vital dans le code système : un mauvais type est une corruption silencieuse. Inférence raisonnable Vitte infère quand c’est sans ambiguïté. Quand le doute existe, vous devez préciser. C’est un compromis qui évite les surprises dans un code long‑vivant. Types composés Vous manipulerez souvent des slices, des buffers, et des structures. Le langage fournit des briques simples pour exprimer ces formes. On verra les structures en détail au chapitre 8. Types comme vocabulaire Nommez vos types comme vous nommez vos fonctions. Un type bien nommé réduit le besoin de commentaires et clarifie l’intention. On préfère souvent un petit type dédié à un alias générique qui ne raconte rien. Les erreurs de type sont des informations Une erreur de type est un message, pas un affront. Elle vous dit que votre modèle mental ne correspond pas au contrat du code. Lisez‑la comme un dialogue. Choisir un type, c’est choisir un futur Un type trop large laisse passer trop d’états invalides. Un type trop strict ralentit l’exploration. Cherchez l’équilibre : le type doit exprimer l’invariant le plus important. À retenir Le type est un contrat. Quand vous doutez, écrivez le type explicitement. Les types racontent une histoire : écrivez‑les pour des lecteurs. Exemple guidé : types explicites Écrivez une fonction qui lit une taille, puis qui alloue un buffer. Écrivez‑la d’abord avec types implicites, puis avec types explicites. Comparez la lisibilité. Erreurs courantes Utiliser un type signé pour une taille. Confondre et dans une API publique. Laisser l’inférence masquer un choix important. Checklist types Les tailles sont non signées. Les identifiants publics ont des types explicites. Les conversions sont visibles. Exercice : le bon type au bon endroit Écrivez une fonction . Version A : est signé. Version B : est non signé. Comparez la clarté des erreurs possibles. Le bon type évite des états invalides. Code complet (API actuelle) API idéale (future) Un constructeur éviterait la boucle manuelle."
  },
  {
    "title": "6. Fonctions et procédures",
    "url": "/book/06-procedures/",
    "text": "6. Fonctions et procédures Une fonction est une promesse : « si vous me donnez ces entrées, je vous rends cette sortie ». Dans Vitte, cette promesse se veut simple, lisible, et stable. Une bonne fonction donne envie de la réutiliser. Définir une procédure Le nom est court et précis. Les paramètres sont explicitement typés. La signature est un point de repère important. Procédures locales Vitte autorise les procédures comme valeurs, ce qui aide à structurer un code de manière locale : Effets et lisibilité Une procédure qui touche l’extérieur (fichier, réseau, horloge) devrait le dire clairement. Le but est de rendre l’effet visible au lecteur. L’ambiguïté est une source de bugs. L’interface comme contrat Une signature simple permet de changer l’implémentation sans toucher aux appelants. Plus votre interface est claire, plus votre code est durable. Petite taille, grande clarté Une procédure courte favorise la compréhension locale. Si une fonction devient longue, posez‑vous la question : est‑ce un seul problème ou plusieurs ? Découper au bon endroit Le bon découpage n’est pas celui qui minimise les lignes, mais celui qui minimise l’effort de compréhension. Un lecteur doit pouvoir comprendre une procédure sans sauter ailleurs toutes les trois lignes. À retenir Les signatures sont des contrats. Une procédure courte vaut mieux qu’une procédure polyvalente. Les effets doivent être visibles. Exemple guidé : clarifier une interface Partir d’une procédure “fourre‑tout”, puis découper en trois fonctions claires. Chaque fonction doit tenir en moins de 15 lignes. Erreurs courantes Utiliser des paramètres “optionnels” sans le dire. Faire une fonction qui “fait un peu de tout”. Cacher un effet derrière une signature trop neutre. Checklist procédures Le nom décrit l’intention. La signature est courte. Les effets sont visibles. Exercice : réduire la signature Prenez une procédure avec six paramètres. Essayez de regrouper ceux qui vont ensemble dans un type dédié. La signature devient plus lisible, et les erreurs d’appel sont moins probables. Code complet (API actuelle) API idéale (future) Un module avec et standard."
  },
  {
    "title": "7. Contrôle de flux",
    "url": "/book/07-controle/",
    "text": "7. Contrôle de flux Le contrôle de flux est la grammaire de votre logique. Si elle est confuse, votre programme le sera aussi. La simplicité des branches est une forme de robustesse. Conditions Les conditions doivent rester lisibles. Évitez les expressions trop denses. Boucles Vitte propose des formes simples : Match est utile quand plusieurs cas sont possibles. Utilisez‑le pour clarifier l’intention. Lisibilité avant tout Un flux de contrôle trop dense rend les bugs invisibles. Privilégiez les branches courtes et les retours explicites. Gérer l’erreur tôt Dans un code système, les erreurs sont normales. La bonne stratégie consiste à les traiter tôt, puis à continuer sur un chemin propre. C’est moins élégant, mais beaucoup plus fiable. Sortir proprement Un retour clair vaut mieux qu’un enchaînement de drapeaux. Le lecteur doit savoir à quel moment la fonction se termine, et pourquoi. À retenir La clarté du flux est plus importante que la concision. Les branches doivent être lisibles en un coup d’œil. Traiter l’erreur tôt améliore tout le reste. Exemple guidé : erreurs d’abord Réécrivez une fonction qui accumule des erreurs en fin de fonction. Transformez‑la pour gérer les erreurs dès qu’elles arrivent. Comparez la clarté. Erreurs courantes Utiliser des flags multiples pour décrire l’état. Écrire des conditions imbriquées trop profondes. Oublier un cas dans . Checklist flux Les branches sont courtes. Les sorties sont explicites. Les erreurs sont gérées tôt. Exercice : aplatir une logique Transformez une chaîne de imbriqués en ou en retours précoces. Lisez ensuite votre code à voix haute : est‑il plus facile à expliquer ? Code complet (API actuelle) API idéale (future) Un type pour les opérations système afin d’éviter les valeurs sentinelles."
  },
  {
    "title": "8. Structures et enums",
    "url": "/book/08-structures/",
    "text": "8. Structures et enums Les structures et enums servent à exprimer des données avec intention. Le lecteur doit comprendre « ce que c’est » avant de comprendre « ce que ça fait ». Structures Une structure regroupe des champs liés. Préférez des structures petites et cohérentes. Exemple conceptuel : Enums Les enums expriment un choix fini. Ils sont utiles pour rendre les états explicites. Modéliser l’intention Un enum bien nommé vous évite des dizaines de commentaires. Il dit clairement « voici toutes les options possibles ». C’est un outil de précision, pas un gadget. Pas de structures “fourre‑tout” Une structure qui finit par contenir « un peu de tout » devient vite un stockage sans intention. Quand vous sentez ce glissement, découpez‑la. Champs dérivés Évitez de stocker des champs qui peuvent être recalculés sans coût significatif. Cela réduit les risques d’incohérence. Une structure doit rester une vérité unique. À retenir Une structure est un nom pour un groupe d’invariants. Une enum est un nom pour un choix fini. Si la syntaxe exacte change, conservez l’intention : donner un nom à un groupe stable. Exemple guidé : refactorer une structure Prenez une structure “fourre‑tout” et découpez‑la en deux structures plus petites. Ajoutez un enum pour rendre les états explicites. Erreurs courantes Stocker des champs dérivés. Utiliser des structures énormes pour éviter de réfléchir au modèle. Mettre des valeurs optionnelles sans les signaler. Checklist structures Chaque champ a une raison d’être. Les champs dérivés sont évités. Les invariants sont documentés. Exercice : structurer un état Imaginez un downloader avec trois états : “en attente”, “en cours”, “terminé”. Écrivez un enum pour ces états, et évitez les drapeaux booléens multiples. Code complet (API actuelle) API idéale (future) Un support plus direct pour les “optionnels” (champ nullable) sans explicite."
  },
  {
    "title": "9. Modules, use, pull, share",
    "url": "/book/09-modules/",
    "text": "9. Modules, use, pull, share Un module est une frontière : ce qui est dedans est stable, ce qui est dehors est protégé par l’interface. En pratique, c’est le meilleur outil pour garder un projet lisible. Charger un module Vous importez ce dont vous avez besoin, rien de plus. Ce geste devrait toujours être intentionnel : on ne « tire » pas un module pour voir si ça marche. Pull et partage sert à importer du code local. expose ce que vous voulez rendre public. Cette séparation force l’intention et limite les dépendances accidentelles. Choisir une architecture Un module par responsabilité. Des noms courts, alignés sur le domaine. Une hiérarchie stable qui facilite la navigation. Interfaces fines Une interface trop large invite les usages inattendus. Préférez une interface petite, lisible, et bien documentée. Un module qui fait peu, mais qui le fait bien, est une excellente brique. Dépendances explicites Une dépendance implicite devient un bug implicite. Rendez vos dépendances visibles, et limitez‑les. C’est le meilleur moyen de garder un code portable. À retenir La modularité est votre meilleure défense contre les dépendances confuses. Exemple guidé : scinder un module Prenez un module qui gère à la fois I/O et parsing. Scindez‑le en deux modules. Vous verrez immédiatement les bénéfices en lisibilité. Erreurs courantes Importer un module “par habitude”. Exposer trop de symboles publics. Créer une hiérarchie trop profonde. Checklist modules Un module = une responsabilité. Les interfaces publiques sont petites. Les dépendances sont visibles. Exercice : modulariser un script Prenez un script monolithique. Déplacez la logique d’I/O dans un module, et la logique métier dans un autre. Mesurez la différence de lisibilité. Code complet (API actuelle) API idéale (future) Un système de modules avec alias et reexports plus explicites pour les grands projets."
  },
  {
    "title": "10. Erreurs et diagnostics",
    "url": "/book/10-diagnostics/",
    "text": "10. Erreurs et diagnostics Les diagnostics sont une partie du langage, pas un ajout. Un bon message d’erreur accélère la compréhension et évite les cycles de debugging inutiles. Lire un diagnostic Prenez l’habitude de lire le code d’erreur. C’est un index stable, utile pour la recherche et la documentation. Un diagnostic est une carte : il vous indique où vous êtes et comment en sortir. Réduire un problème Quand une erreur est confuse : Isolez le cas minimal. Supprimez ce qui n’est pas nécessaire. Vérifiez que l’erreur reste. Cette discipline accélère autant votre compréhension que celle des autres. Messages utiles Un bon diagnostic répond à trois questions : où ? quoi ? pourquoi ? Le reste est secondaire. Des erreurs actionnables L’erreur idéale ne se contente pas de dire « c’est faux ». Elle vous suggère une action simple : ajouter un type, corriger un module, ou renommer un identifiant. Ce n’est pas un luxe : c’est un outil de productivité. Le diagnostic comme documentation Les erreurs bien formulées deviennent une documentation vivante. Elles vous apprennent la grammaire, les conventions, et les limites du langage, sans vous renvoyer systématiquement à un manuel externe. À retenir Le meilleur diagnostic est celui qui vous pousse vers l’action suivante, pas celui qui vous explique toute l’histoire. Exemple guidé : écrire un message d’erreur Créez un diagnostic avec : une description courte,. le contexte,. une action suggérée. Comparez avec un message “brut” sans action. Vous verrez la différence d’utilisabilité. Erreurs courantes Messages trop longs sans action. Messages vagues (“error occurred”). Oubli du contexte (fichier, ligne). Checklist diagnostics Le message dit quoi faire. Le contexte est présent. Le code d’erreur est stable. Exercice : un message utile Créez un message d’erreur pour “fichier introuvable”. Comparez la version brute et une version qui inclut : le chemin,. l’action tentée,. la suggestion (“vérifiez le chemin”). Code complet (API actuelle) API idéale (future) Un enrichi avec des codes d’erreur et des conseils d’action."
  },
  {
    "title": "11. Collections et itération",
    "url": "/book/11-collections/",
    "text": "11. Collections et itération Les collections sont l’ossature des programmes réels. Vous manipulerez des listes, des maps, et des buffers, parfois très grands. L’objectif est d’être explicite sur ce que vous stockez et sur la manière dont vous parcourez ces données. Itération claire La lisibilité prime. Une boucle courte et un bon nom de variable valent mieux qu’un « truc malin ». L’itération est la partie de votre code la plus lue : elle doit être simple. Choisir la bonne structure Liste quand l’ordre compte. Map quand la clé compte. Buffer quand la performance compte. Coût des opérations La plupart des bugs de performance viennent d’un choix implicite de structure. Une collection n’est pas neutre : elle impose un coût de lecture, d’écriture, et de mémoire. Slices et vues Une bonne pratique consiste à exposer des vues (slices) plutôt que des copies. Cela réduit la mémoire et évite les surprises, tant que la durée de vie est claire. Itération et invariants Ne parcourez pas une collection sans savoir ce que vous en attendez. Une boucle qui ne décrit pas son objectif est une boucle dangereuse. Ajoutez un commentaire d’intention si nécessaire. Erreurs courantes Muter une collection pendant l’itération sans le dire. Utiliser une liste quand une map est requise. Copier de gros buffers par accident. À retenir Le choix d’une collection est un choix d’interface. Un mauvais choix se paye en complexité. Exemple guidé : choisir la structure Vous devez compter des occurrences de mots. Écrivez d’abord avec une liste, puis avec une map. Comparez la complexité. Checklist collections La structure correspond à l’usage dominant. Les copies sont évitées. L’itération reste lisible. Exercice : éviter la copie Créez une fonction qui reçoit une liste de 10 000 éléments. Faites une version qui copie, puis une version qui utilise une vue. Comparez la mémoire. Code complet (API actuelle) Exemple : compter les occurrences d’un mot avec une map naïve (ici une liste de paires, faute de map dédiée dans la stdlib). API idéale (future) On voudrait une standard, avec , , et . L’exemple ci‑dessus deviendrait un one‑liner."
  },
  {
    "title": "12. Pointeurs, références, slices",
    "url": "/book/12-pointeurs/",
    "text": "12. Pointeurs, références, slices Vitte vous laisse proche de la mémoire, mais sans vous obliger à écrire des acrobaties. La clé est de rendre les accès explicites et sûrs. Pointeurs Les pointeurs donnent la puissance, mais ils demandent une discipline stricte. Utilisez‑les seulement quand vous savez pourquoi. La règle simple : si une référence suffit, restez avec une référence. Références Les références rendent la lecture plus simple. Elles expriment une intention claire : « j’utilise cette valeur sans en prendre la propriété ». Slices et buffers Un slice est un regard sur une portion d’un buffer. Il permet de manipuler une sous‑partie sans copier. C’est un outil simple, mais essentiel pour les traitements efficaces. Durée de vie La plupart des bugs mémoire viennent d’une durée de vie mal comprise. Un pointeur qui “survit” à son buffer est un bug discret et coûteux. Erreurs courantes Garder un pointeur vers un buffer temporaire. Confondre taille et capacité. Exposer un buffer mutable alors qu’une vue aurait suffi. À retenir Un pointeur est un outil, pas une habitude. Un slice est un contrat de taille et de vue. La durée de vie est une information de premier ordre. Exemple guidé : durée de vie explicite Créez un buffer dans une fonction, renvoyez un slice, puis montrez ce qui se passe si la durée de vie est mal gérée. Ajoutez ensuite une version correcte. Checklist mémoire La durée de vie est claire. Les pointeurs ne survivent pas à leur source. Les vues sont préférées aux copies. Exercice : durée de vie Créez une fonction qui retourne un pointeur vers une variable locale. Comprenez pourquoi c’est un bug, puis corrigez‑la. Cet exercice est brutal, mais formateur. Code complet (API actuelle) Exemple : une fonction qui lit dans un buffer existant via un pointeur. API idéale (future) Un type avec invariants de durée de vie rendrait ce genre de code plus sûr et plus expressif."
  },
  {
    "title": "13. Génériques",
    "url": "/book/13-generiques/",
    "text": "13. Génériques Les génériques servent à écrire une logique une fois, puis à la réutiliser sans perdre la sécurité des types. Ils sont utiles, mais doivent rester lisibles. Quand les utiliser Quand une fonction est conceptuellement la même pour plusieurs types. Quand une structure a un rôle identique pour plusieurs formes de données. Quand les éviter Quand le code devient opaque. Quand l’interface générique cache une logique trop spécifique. Lire un code générique Le lecteur doit pouvoir comprendre l’intention sans apprendre un mini‑langage. Si un générique demande trop de contexte, c’est qu’il est trop ambitieux. Contrainte et clarté Si votre générique nécessite des contraintes complexes, il est peut‑être trop large. Une bonne contrainte est une phrase courte : « T doit être comparable », « T doit être copiable ». Erreurs courantes Exposer un générique quand une version concrète suffit. Trop généraliser trop tôt. Utiliser des noms de type confus. À retenir Les génériques sont puissants, mais la clarté reste le premier objectif. Exemple guidé : un générique raisonnable Implémentez une fonction générique, puis une version concrète. Comparez le coût cognitif. Le but est d’apprendre quand généraliser. Checklist génériques Le générique réduit vraiment la duplication. Les contraintes sont simples. Les noms de type sont lisibles. Exercice : généraliser ou pas Écrivez deux versions d’une fonction de tri : une pour , une générique. Comparez la lisibilité et la maintenance. Code complet (API actuelle) Exemple : une fonction générique simple. API idéale (future) Une contrainte éviterait de passer un comparateur à chaque appel."
  },
  {
    "title": "14. Macros",
    "url": "/book/14-macros/",
    "text": "14. Macros Les macros sont un outil tranchant. Elles peuvent clarifier un motif répétitif, mais elles peuvent aussi masquer le code. Vitte encourage une utilisation prudente. Un exemple simple Quand les utiliser Pour factoriser un motif purement syntaxique. Pour éviter une répétition qui ne porte pas de sens. Quand les éviter Pour cacher des effets. Pour « simplifier » une logique complexe. Le coût cognitif Chaque macro ajoute une couche de lecture. Utilisez‑les comme des outils de scalpel, pas comme des raccourcis universels. Erreurs courantes Faire dépendre la logique métier d’une macro obscure. Cacher un appel système. Utiliser une macro alors qu’une fonction claire suffit. À retenir Une macro doit rendre le code plus lisible, jamais l’inverse. Exemple guidé : macro vs fonction Implémentez un motif avec une macro, puis avec une fonction. Gardez la version la plus lisible. Les macros sont rares par défaut. Checklist macros La macro simplifie la lecture. Les effets sont visibles. La macro est documentée. Exercice : éliminer une macro Prenez une macro existante et réécrivez‑la en fonction. Si la lisibilité augmente, gardez la fonction. Code complet (API actuelle) API idéale (future) Une macro d’assertion avec message, fichier, et ligne réduirait le coût de débogage."
  },
  {
    "title": "15. HIR, MIR et pipeline",
    "url": "/book/15-pipeline/",
    "text": "15. HIR, MIR et pipeline La compilation est un pipeline. La comprendre vous fait gagner un temps énorme quand vous déboguez un programme ou un bug du compilateur. Les grandes étapes Parsing et AST : le texte devient structure. HIR : les formes sont normalisées. MIR : le programme est prêt pour la génération. Backend : le binaire est produit. Pourquoi cela compte Quand un bug apparaît, savoir dans quel étage il se trouve réduit immédiatement l’espace de recherche. Vous pouvez poser de meilleures questions et éviter les hypothèses floues. Méthode de diagnostic Reproduire le problème. Localiser l’étape qui change l’information. Inspecter les sorties intermédiaires. HIR : rendre explicite Le HIR simplifie la structure pour rendre les décisions explicites. C’est la première étape où le compilateur commence à “comprendre” ce que vous avez écrit. MIR : préparer le terrain Le MIR est le niveau où les transformations deviennent mécaniques. L’objectif est d’obtenir une forme qui se traduit proprement vers le backend. À retenir Comprendre la pipeline, même à haut niveau, est une compétence centrale pour travailler proche de la machine. Exemple guidé : diagnostiquer un bug Supposez qu’un se compile mal. Essayez de localiser si le bug est dans le parsing, le HIR, ou le MIR. Cette méthode réduit drastiquement le temps de debug. Checklist pipeline Vous savez reproduire le bug. Vous savez isoler l’étape fautive. Vous savez vérifier l’output intermédiaire. Exercice : tracer une erreur Simulez une erreur de parsing, puis une erreur de type. Notez comment elles apparaissent dans le pipeline. Cette observation vous aide à classifier rapidement les bugs. Code complet (API actuelle) Exemple conceptuel : compiler en mode normal, puis activer les sorties intermédiaires si votre driver les expose. API idéale (future) Un mode qui enregistre automatiquement les étapes dans un dossier daté."
  },
  {
    "title": "16. Backend C++ et interop",
    "url": "/book/16-interop/",
    "text": "16. Backend C++ et interop Vitte peut générer du C++ pour tirer parti d’outils existants. L’objectif n’est pas de « cacher » le C++, mais d’offrir une voie d’intégration claire. Interop simple Vous pouvez appeler une fonction externe. Vous pouvez lier une bibliothèque existante. L’important est de documenter l’ABI et la convention d’appel. Pensée “frontière” L’interop est une frontière : vous passez d’un monde à l’autre. Assurez‑vous que chaque côté sait ce que l’autre attend. Stratégie d’intégration Commencez par une fonction simple, documentée, et testée. Puis élargissez progressivement. L’interop réussie est une série d’étapes petites, jamais un “big bang”. Erreurs courantes Oublier la convention d’appel. Mélanger des types qui ne partagent pas la même taille ou le même alignement. Ne pas tester l’interface côté C/C++ et côté Vitte. À retenir Interopérer, c’est accepter deux mondes. Le contrat d’interface est ce qui évite les surprises. Exemple guidé : appeler une fonction C Définissez une fonction , documentez son ABI, puis appelez‑la. Testez avec un petit programme C séparé. Checklist interop ABI documentée. Types alignés. Tests croisés Vitte/C. Exercice : alignement Définissez une structure côté C et côté Vitte. Vérifiez que la taille et l’alignement correspondent. C’est une erreur classique quand on débute en interop. Code complet (API actuelle) API idéale (future) Un module avec des helpers de conversion réduirait la friction."
  },
  {
    "title": "17. Standard library (tour guidé)",
    "url": "/book/17-stdlib/",
    "text": "17. Standard library (tour guidé) La bibliothèque standard est volontairement pragmatique. Elle vise à couvrir l’essentiel sans cacher les détails importants. Navigation Commencez par les modules de base : I/O, OS, process, cli. Ce sont ceux qui reviennent dans presque tous les projets. Exemple rapide Philosophie La stdlib propose des primitives lisibles, pas un framework. Elle vous accompagne sans vous enfermer. Comment la lire Lisez les modules comme des mini‑bibliothèques. Cherchez les types principaux, puis les fonctions d’entrée. Une bonne lib se comprend en trois étapes : surface, détails, contraintes. Erreurs courantes Utiliser un module parce qu’il existe, pas parce qu’il est nécessaire. Appeler la stdlib sans lire la signature. À retenir La stdlib est un outil, pas un mode de vie. Exemple guidé : lire et écrire Prenez un module I/O, écrivez un petit utilitaire, puis réduisez‑le pour isoler l’essentiel. La stdlib se comprend en pratique. Checklist stdlib Vous connaissez les modules essentiels. Vous lisez les signatures avant d’utiliser. Vous évitez les dépendances inutiles. Exercice : petit utilitaire Écrivez un utilitaire de ligne de commande qui lit un fichier et compte les lignes. L’objectif est de manipuler deux modules std et de rester lisible. Code complet (API actuelle) API idéale (future) Un module pourrait générer automatiquement et valider les arguments."
  },
  {
    "title": "18. Tests et outillage",
    "url": "/book/18-tests/",
    "text": "18. Tests et outillage Un bon test est un document vivant. Il capture l’intention et vous protège contre les régressions. Dans un langage système, un test est aussi un garde‑fou de sécurité. Types de tests Tests unitaires pour les fonctions critiques. Tests d’intégration pour les flux complets. Tests de non‑régression pour les bugs corrigés. L’outillage Le principe est simple : un test doit être rapide à lancer et facile à comprendre. Les scripts de test du repo sont pensés dans cet esprit. Un bon test Un bon test est court, précis, et raconte une histoire. Si vous devez relire le test trois fois pour comprendre ce qu’il fait, le test est trop complexe. Tests comme documentation Un test est une preuve. Quand vous revenez six mois plus tard, c’est souvent plus clair qu’un commentaire. Écrivez des tests comme des exemples explicites. Erreurs courantes Tester trop de choses dans un seul test. Écrire un test qui dépend de l’ordre d’exécution. Utiliser des données aléatoires sans seed. À retenir Les tests ne sont pas un coût, ils sont une assurance. Exemple guidé : un test de bug Reproduisez un bug réel (même petit), puis écrivez un test minimal. C’est une pratique clé pour un langage en évolution. Checklist tests Tests courts. Tests stables. Tests qui racontent une histoire. Exercice : test minimal Prenez un bug corrigé et écrivez un test qui échoue avant le fix et passe après. Ce test est votre mémoire technique. Code complet (API actuelle) Exemple : test de non‑régression (conceptuel) basé sur un binaire. API idéale (future) Un framework de test intégré (assertions, fixtures, snapshots) simplifierait l’écriture de tests."
  },
  {
    "title": "19. Performance et profiling",
    "url": "/book/19-performance/",
    "text": "19. Performance et profiling Optimiser trop tôt est une erreur, mais ignorer la performance est une dette. Ce chapitre propose une méthode simple : mesurer, comprendre, optimiser. Mesurer Avant toute optimisation, collectez des chiffres. Un gain supposé est rarement un gain réel. Hot paths Concentrez‑vous sur les chemins chauds. La performance est un problème de priorité, pas de perfection. Optimisation lisible Un micro‑gain qui détruit la lisibilité n’est pas une victoire. Le meilleur code rapide est celui qui reste clair. Règle de trois Mesurer. Comprendre. Modifier. Si vous sautez une étape, vous n’optimisez pas : vous devinez. Erreurs courantes Optimiser une partie non critique. Cacher une allocation qui aurait pu être visible. Sacrifier la clarté pour un gain marginal. À retenir La meilleure optimisation est celle qui simplifie le code tout en accélérant le chemin critique. Exemple guidé : mesurer un hot path Choisissez une fonction lente, mesurez‑la, modifiez un point, puis mesurez à nouveau. La performance sans mesure est un mythe. Checklist perf Mesure avant modification. Modification claire. Mesure après modification. Exercice : mesurer avant d’optimiser Créez une boucle volontairement lente, mesurez‑la, puis optimisez un seul point. Si le gain n’est pas mesuré, annulez l’optimisation. Code complet (API actuelle) Exemple minimal : compiler et mesurer la version de base avant toute optimisation. API idéale (future) Un outil qui collecte automatiquement des compteurs et produit un rapport."
  },
  {
    "title": "20. Reproductibilité et builds",
    "url": "/book/20-repro/",
    "text": "20. Reproductibilité et builds Un build reproductible est un build fiable. Si le même code produit des binaires différents, vous perdez votre base de confiance. Principe Fixer les versions d’outils. Réduire les sources d’entropie (timestamps, chemins, etc.). Comparer les artefacts. Pourquoi c’est important La reproductibilité est une base de sécurité et de débogage. Elle facilite aussi la collaboration. Technique simple Commencez par comparer des hashes et comprendre chaque différence. La reproductibilité est une discipline, pas un bouton magique. Erreurs courantes Compiler sur deux machines sans aligner les outils. Comparer des binaires signés sans enlever les signatures. Ne pas documenter le pipeline de build. À retenir Un build reproductible est un build explicable. Exemple guidé : build reproductible Construisez un binaire deux fois, comparez les hashes. Puis identifiez la source de divergence (timestamp, chemin, signature). C’est un exercice fondamental. Checklist repro Outils alignés. Sources d’entropie réduites. Comparaison systématique. Exercice : identifier l’entropie Construisez deux fois, comparez les hashes, puis identifiez la source d’entropie. Documentez‑la dans le README du projet. Code complet (API actuelle) API idéale (future) Un qui liste toutes les sources d’entropie détectées."
  },
  {
    "title": "'21. Projet 1 : CLI robuste'",
    "url": "/book/21-projet-cli/",
    "text": "21. Projet 1 : CLI robuste Nous allons construire un outil de ligne de commande propre, avec parsing d’arguments, validation, et sorties lisibles. Ce projet sert de base à plusieurs chapitres. L’objectif n’est pas de faire un « outil parfait », mais un outil que vous pouvez expliquer et maintenir. Cahier des charges Notre CLI, que l’on appellera , va : Lire un fichier et l’écrire sur . Offrir une option pour limiter le nombre de lignes. Fournir des erreurs claires en cas de fichier manquant. Étape 1 : définir l’interface Avant d’écrire la moindre ligne, décrivez l’interface en une phrase : affiche le contenu. affiche les 10 premières lignes. Une interface claire réduit la complexité de tout le reste. Étape 2 : parser les arguments Utilisez la stdlib pour obtenir les arguments, puis validez : Le parsing n’est pas un détail. C’est la première interaction avec l’utilisateur, et c’est souvent là que les bugs se cachent. Variante : valeurs par défaut Décidez si a une valeur par défaut. Si oui, documentez‑la et testez‑la. Les valeurs implicites sont utiles, mais dangereuses si elles ne sont pas expliquées. Erreur courante Accepter sans validation. Étape 3 : lire le fichier Créez une fonction dédiée, courte, et testable. Le but est de séparer l’I/O de l’interface. Variante : support de Vous pouvez décider que signifie « lire depuis stdin ». C’est un comportement classique, mais il doit être explicitement documenté. Étape 4 : gérer les erreurs Chaque erreur doit expliquer : Ce qui s’est passé. Où ça s’est passé. Quelle action est possible. Erreur courante Retourner un code d’erreur sans message. Étape 5 : tests Écrivez au moins trois tests : Fichier existant. Fichier manquant. Option . Variante : tests de performance Testez un fichier volumineux pour vérifier que la mémoire n’explose pas. Étape 6 : documentation minimale Une CLI sans est une CLI incomplète. Même une documentation courte évite des tickets et des bugs. À retenir Un outil CLI fiable se juge à la qualité de ses erreurs. Un outil lisible est un outil qui survit à son auteur. Pas‑à‑pas détaillé Écrire un parser d’arguments minimal. Définir un mode explicite. Implémenter la lecture de fichier en mode streaming. Ajouter la limite . Ajouter des erreurs claires. Erreurs fréquentes Ne pas valider les arguments numériques. Oublier de fermer le fichier. Écrire sur des erreurs qui doivent aller sur . Variantes avancées Ajouter un mode . Supporter plusieurs fichiers et concaténer proprement. Ajouter des tests de performance. Code complet (version pédagogique) Le code ci‑dessous est volontairement verbeux et commenté. Il privilégie la lisibilité. Les appels d’I/O sont schématiques : adaptez‑les aux APIs exactes de la stdlib. Pourquoi ce style Chaque fonction fait une seule chose. Les erreurs sont gérées tôt. Les noms racontent l’intention. À améliorer ensuite Gestion de . Limiter la mémoire en streaming. Codes de sortie distincts. Atelier : durcir l’outil Ajoutez ces comportements : doit refuser les valeurs négatives. doit refuser les valeurs non numériques. Un message d’erreur doit aller sur . Le but est d’apprendre que la robustesse se construit par petites décisions. Code complet (API actuelle) Ce code utilise les modules , , et . API idéale (future) . pour parser les options et générer l’aide automatiquement. pour itérer sans ambiguïté sur les lignes vides."
  },
  {
    "title": "'22. Projet 2 : mini‑serveur (version détaillée)'",
    "url": "/book/22-projet-http/",
    "text": "22. Projet 2 : mini‑serveur (version détaillée) Ce projet montre comment assembler plusieurs modules pour gérer un flux I/O continu. L’idée est de rester simple : pas de magie, seulement des blocs clairs. Un mini‑serveur est un excellent exercice, car il combine lecture, parsing, réponse, et gestion des erreurs dans un flux répétitif. Ce chapitre développe le projet au maximum en paragraphes continus, sans listes, et avec un fil pédagogique clair. Étape 0 : cadrer l’objectif Nous voulons un serveur qui écoute un port, lit une requête HTTP simple, puis répond avec un texte fixe. Ce n’est pas un serveur complet, c’est un exercice de structure. L’objectif est de comprendre le flux “accepter → lire → répondre → fermer”. Ce flux doit être clair, car il sera répété pour chaque connexion. Étape 1 : définir le flux principal Un serveur est une boucle. Vous acceptez une connexion, vous lisez, vous répondez, vous fermez. Tout le reste est du détail. La meilleure stratégie est de coder ce flux en premier, même avec des fonctions vides, pour voir l’architecture globale. Étape 2 : parsing minimal Le parsing HTTP peut être complexe, mais nous ne voulons pas cette complexité ici. Nous voulons seulement extraire la première ligne. Cela suffit pour comprendre la structure d’une requête et pour introduire une séparation claire entre lecture et logique. Étape 3 : réponse simple La réponse doit être un texte fixe avec un header . Ce header est une excellente occasion de rappeler que la protocolisation est un contrat. Si est incorrect, le client se bloque. Ce détail montre pourquoi la précision compte, même dans un exemple simple. Étape 4 : erreurs et logs Un serveur sans logs est un serveur aveugle. Mais un serveur trop bavard est un serveur qui noie l’information. La règle pragmatique est de loguer les erreurs et les événements importants, pas chaque octet lu. L’objectif est d’avoir un signal utile, pas un bruit constant. Étape 5 : version minimale fonctionnelle (API actuelle) L’exemple suivant utilise , , , et . Le code est volontairement explicite. Il privilégie la lisibilité à la sophistication. Ce code est minimal, mais il montre un flux complet. Il est suffisant pour comprendre un serveur sans se perdre dans les détails d’HTTP. Étape 6 : limiter la taille des requêtes Un serveur qui lit sans limite est vulnérable. La discipline consiste à imposer un plafond de lecture. Même un serveur minimal doit définir une limite raisonnable, comme 4 KB ou 8 KB, pour éviter une consommation mémoire incontrôlée. Cette limite est une forme de sécurité. Étape 7 : timeouts Un serveur sans timeout peut rester bloqué indéfiniment sur un client silencieux. La solution est simple : un timeout de lecture ou un timeout de connexion. Même si l’API est bas niveau, le concept doit être intégré dès maintenant. Un timeout est un contrat de disponibilité. Étape 8 : stabilité du protocole Le protocole HTTP a des règles strictes. Même si nous ne respectons pas tout, nous devons respecter l’essentiel : status line, headers, séparation . C’est ce qui rend notre serveur compatible avec un client standard. Étape 9 : variantes utiles Vous pouvez ajouter un endpoint , ou rendre la réponse dynamique en fonction d’un paramètre simple. Ces variantes doivent rester petites. Le but est de garder un code lisible, pas de simuler un framework. Étape 10 : sécurité minimale Même un serveur minimal doit éviter certains pièges : accepter des requêtes infinies, accepter des lignes trop longues, ou répondre avec un incorrect. Ces erreurs ne sont pas des détails, elles sont des bugs de protocolisation. Conclusion Vous avez construit un mini‑serveur lisible et stable. Vous avez appris le flux principal, la discipline du parsing minimal, et l’importance des limites. La valeur de ce projet n’est pas dans la richesse des fonctionnalités, mais dans la clarté de l’architecture. C’est cette clarté qui vous permettra d’ajouter des fonctionnalités sans créer un monstre illisible. Étape 11 : routing minimal Le routing n’a pas besoin d’un framework. Un simple sur la première ligne de la requête suffit pour distinguer et . La règle est de garder cette logique lisible et localisée. Si vous commencez à empiler les routes, il faut alors extraire une fonction dédiée, mais tant que le nombre de routes est faible, la clarté prime. Étape 12 : parsing plus robuste Le parsing minimal lit une ligne. Un parsing un peu plus robuste doit identifier la méthode, le chemin, et la version. Cela reste simple, mais la structure doit être explicite. Le lecteur doit comprendre en une minute comment la ligne est découpée. Toute astuce de parsing qui rend le code opaque est un coût futur. Étape 13 : headers essentiels Les headers HTTP ne sont pas infinis. Pour un mini‑serveur, vous pouvez en gérer deux ou trois : , , et éventuellement . L’important est de ne pas ignorer ce que vous dites. Si vous envoyez un header, il doit être correct. Un header incorrect est pire qu’une absence de header. Étape 14 : keep‑alive et fermeture propre Un serveur minimal peut fermer après chaque réponse, mais un serveur plus réaliste peut accepter . Cela ajoute de la complexité, car vous devez relire plusieurs requêtes sur la même connexion. La bonne stratégie est d’implémenter d’abord la fermeture propre, puis d’ajouter le keep‑alive seulement si vous en avez besoin. Étape 15 : limites et protection Imposez une limite stricte sur la taille de la requête et sur la taille des headers. Même un serveur pédagogique doit éviter de se faire saturer par un client trop bavard. Ce choix est une forme de sécurité, pas une optimisation. Étape 16 : tests manuels simples Testez votre serveur avec un navigateur, puis avec un client simple (curl ou netcat). Observez si la réponse est correcte, si le header correspond, et si la connexion se ferme proprement. Ces tests sont rapides et donnent un signal fiable. Étape 17 : erreurs explicites Les erreurs doivent être visibles. Une erreur de parsing doit produire un message clair, et un status . Une erreur interne doit produire un . Même si ces réponses sont minimales, elles rendent votre serveur plus professionnel. Étape 18 : version “presque production” Une version presque production n’est pas un serveur complet, mais elle respecte trois règles : limites strictes, réponses correctes, et fermeture propre. Si votre mini‑serveur respecte ces règles, il devient un excellent socle pour apprendre et pour étendre sans chaos."
  },
  {
    "title": "'23. Projet 3 : utilitaire système (version détaillée)'",
    "url": "/book/23-projet-sys/",
    "text": "23. Projet 3 : utilitaire système (version détaillée) Un utilitaire système est un bon test de robustesse. Il touche des fichiers, des processus, et souvent des privilèges. C’est aussi un excellent terrain pour apprendre à écrire un code qui respecte la plateforme. Ce chapitre développe le projet au maximum en paragraphes continus, sans listes, et avec un fil pédagogique clair. L’objectif n’est pas d’écrire un outil “complet”, mais un outil lisible, stable, et explicable. Étape 0 : définir l’intention Avant d’écrire une ligne, définissez l’intention en une phrase. Notre outil liste un répertoire, calcule la taille totale, et affiche un résumé. Ce choix paraît simple, mais il force déjà des décisions claires : comment lire un répertoire, comment gérer les erreurs de permission, et comment formater la sortie pour être utile. Étape 1 : structure minimale Un outil système doit commencer par une structure simple. Un fichier principal, quelques fonctions, et un flux clair. L’erreur classique est de mélanger l’I/O avec la logique de calcul. La correction est d’écrire une fonction qui lit, et une fonction qui calcule. Cette séparation rend le code testable et lisible. Étape 2 : lecture de répertoire Lire un répertoire est une opération qui peut échouer. Un dossier peut être absent, inaccessible, ou verrouillé. La lecture doit donc produire un résultat explicite. Si l’API renvoie une erreur, votre outil doit le dire clairement. Un utilitaire système qui échoue en silence est inutile. Étape 3 : calcul de taille Calculer une taille est simple sur le papier, mais dangereux si vous oubliez des cas. Par exemple, un fichier peut être un lien ou un dossier. Votre outil doit choisir une règle claire, puis l’appliquer partout. La règle la plus simple est de ne compter que les fichiers réguliers. Si vous décidez d’inclure les dossiers, documentez-le. Étape 4 : format d’affichage L’affichage est une forme de contrat. Un format stable permet à l’utilisateur d’écrire des scripts autour de votre outil. Évitez les sorties ambiguës. Un format simple comme “total: X” est mieux qu’un format riche mais instable. La clarté est une fonctionnalité. Étape 5 : version minimale fonctionnelle Voici un exemple minimal qui lit un répertoire, calcule une taille, puis l’affiche. Ce code est volontairement simple, et il privilégie la lisibilité. Ce code exprime l’essentiel. Il est imparfait, mais il est clair. Une version robuste se construit toujours sur cette base. Étape 6 : erreurs explicites Un utilitaire système doit être explicite sur ses erreurs. Un message court et actionnable vaut mieux qu’un message long et vague. Par exemple, “cannot read dir: /path” est plus utile que “error”. Cette discipline améliore la fiabilité de l’outil et la confiance de l’utilisateur. Étape 7 : variantes utiles Une variante utile est l’ajout d’un format JSON. Cette variante force à séparer la collecte de données de la présentation. Une autre variante est l’ajout d’un filtre , qui oblige à valider des arguments. Ces variantes sont pédagogiques : elles montrent comment l’outil peut évoluer sans perdre la lisibilité. Étape 8 : tests simples et robustes Les tests doivent couvrir trois cas : un répertoire vide, un répertoire rempli, et un cas de permission refusée. Ces trois tests suffisent à vérifier la logique principale et les erreurs. Un test qui ne couvre que le cas nominal donne une fausse confiance. Étape 9 : discipline de lisibilité Un utilitaire système n’est jamais “fini”. Il évolue. La discipline qui le maintient est la lisibilité. Si votre outil devient difficile à relire, il devient fragile. La lisibilité est le vrai mécanisme de stabilité. Conclusion Vous avez construit un utilitaire système simple, mais robuste. Vous avez appris à séparer l’I/O de la logique, à rendre les erreurs visibles, et à garder un format stable. Cette discipline est exactement ce qui rend un outil durable. Un utilitaire système n’a pas besoin d’être complexe pour être sérieux. Il a besoin d’être clair, stable, et prévisible. Étape 10 : permissions et cas refusés Les permissions sont un vrai problème dans les outils système. Un répertoire peut être lisible mais un sous‑dossier peut être bloqué. Votre outil doit décider comment réagir : ignorer, avertir, ou échouer. La meilleure stratégie est d’avertir clairement tout en continuant, sauf si l’objectif de l’outil est strictement la précision totale. Cette décision doit être explicite dans le code et documentée. Étape 11 : liens symboliques et boucles Les liens symboliques peuvent créer des cycles. Si vous parcourez un arbre en profondeur, vous risquez de boucler à l’infini. La discipline consiste à détecter ces liens et à éviter une récursion infinie. Vous pouvez choisir de les ignorer, ou de les traiter comme des fichiers, mais vous devez choisir. Un comportement implicite ici est une source de bugs critiques. Étape 12 : récursivité contrôlée Un utilitaire qui parcourt des dossiers finit souvent par devenir récursif. La récursivité doit être contrôlée : profondeur maximale, stratégie d’arrêt, et gestion des erreurs par niveau. Un parcours récursif non contrôlé peut transformer un outil simple en outil dangereux. Étape 13 : performance et scalabilité La performance est secondaire jusqu’à un certain point, mais un outil système peut être utilisé sur de très grands dossiers. Dans ce cas, l’important est d’éviter les allocations inutiles et de minimiser les appels système. Une stratégie simple est de traiter les entrées en streaming plutôt qu’en chargeant tout en mémoire. Ce gain est souvent plus important que des optimisations locales. Étape 14 : formatage et stabilité d’interface Un format de sortie stable est une promesse pour les utilisateurs. Si votre outil change son format à chaque version, il casse les scripts. La stabilité vaut parfois plus que la beauté. C’est pourquoi il faut choisir un format simple, documenté, et durable."
  },
  {
    "title": "'24. Projet 4 : base de données key‑value (version détaillée)'",
    "url": "/book/24-projet-kv/",
    "text": "24. Projet 4 : base de données key‑value (version détaillée) Une base key‑value est un excellent exercice : structure de données, I/O, et cohérence. C’est aussi une bonne manière d’apprendre à gérer la corruption et les formats. Ce chapitre développe le projet au maximum en paragraphes continus, en gardant la lisibilité comme objectif principal. Le but n’est pas de rivaliser avec une base industrielle, mais de construire un système simple, explicable, et robuste. Étape 0 : pourquoi une key‑value Une base key‑value est la plus petite base possible. Elle ne fait qu’une chose : associer une clé à une valeur. Cette simplicité est un avantage pédagogique. Vous pouvez isoler les problèmes essentiels, comme la gestion des fichiers, la sérialisation, et la cohérence. Une base relationnelle serait trop large pour cet apprentissage. Ici, nous voulons comprendre chaque étape. Étape 1 : définir un format stable Le format de stockage est le cœur de la base. Si vous changez le format, vous cassez la compatibilité. C’est pourquoi il doit être simple et stable. Un format classique consiste à écrire, pour chaque entrée, la taille de la clé, la taille de la valeur, puis les bytes. Cette structure est lisible, facile à déboguer, et suffisante pour un projet pédagogique. Ce format a un avantage important : il est append‑only. Chaque entrée est ajoutée à la fin, ce qui rend l’écriture simple et robuste. Ce n’est pas le format le plus rapide, mais il est le plus facile à expliquer et à maintenir. Étape 2 : écrire une entrée L’écriture consiste à transformer une clé et une valeur en une séquence de bytes, puis à les écrire à la fin du fichier. La robustesse vient de la discipline : chaque écriture doit être complète, chaque taille doit être valide, et chaque erreur doit être signalée. Dans un projet réel, on écrirait un checksum. Ici, vous pouvez déjà préparer cette idée. Même si la stdlib offre un module , l’objectif est de comprendre la logique. Vous pouvez utiliser ce module pour l’I/O, mais conservez la structure mentale : écrire une entrée, vérifier le résultat, et rendre l’erreur visible. Étape 3 : lire une valeur La lecture est plus coûteuse en append‑only. Vous devez parcourir le fichier et garder la dernière valeur de la clé. Ce n’est pas “optimal”, mais c’est stable et compréhensible. Dans un projet pédagogique, la lisibilité prime. L’optimisation viendra plus tard. Pour rendre la lecture plus fiable, vous devez vérifier la cohérence du fichier. Si une taille lue dépasse la taille réelle du fichier, vous avez probablement une corruption. Dans ce cas, il faut s’arrêter et signaler l’erreur. Une lecture qui continue malgré une corruption est un bug sérieux. Étape 4 : index en mémoire L’append‑only est simple mais lent. Une amélioration naturelle consiste à construire un index en mémoire : une map clé → offset. Vous parcourez le fichier une fois au démarrage et vous enregistrez la position de chaque clé. Ensuite, la lecture devient quasi instantanée. Cette étape ajoute de la complexité, mais elle est contrôlée. La discipline ici est de séparer le “build d’index” et la “lecture”. L’index est un cache. Il doit être reconstructible. Ne le traitez jamais comme une vérité permanente. Étape 5 : compaction Une base append‑only grandit à l’infini. La compaction consiste à réécrire un fichier propre qui ne contient que les dernières valeurs. Cette étape est essentielle pour éviter une explosion de taille. La compaction est aussi un exercice de rigueur : il faut copier correctement, vérifier les tailles, et remplacer l’ancien fichier de manière sûre. Une bonne compaction est atomique : écrire dans un fichier temporaire, puis remplacer l’original. Cela évite les corruptions en cas de crash. Étape 6 : gestion des erreurs Une base sans erreurs visibles est une base dangereuse. Les erreurs doivent être courtes, actionnables, et stables. Un message “db read failed” est insuffisant. Un message “db read failed: unexpected EOF” est utile. Les erreurs sont un outil de maintenance, pas un bruit. Étape 7 : API minimale Une API minimale suffit pour ce projet : , , , , . Ces opérations couvrent l’essentiel. Chaque opération doit être claire et prévisible. L’API est un contrat avec l’utilisateur. Elle doit être stable. Étape 8 : tests et non‑régression Les tests doivent couvrir les cas simples et les cas de corruption. Un test qui écrit une clé, relit, puis supprime est un bon début. Un test qui simule une corruption de taille est un meilleur test. Le but est de vérifier la robustesse, pas seulement la fonctionnalité nominale. Étape 9 : lecture et écriture via la stdlib Si vous utilisez , vous bénéficiez d’un backend existant. Mais vous devez toujours comprendre ce qui se passe. Le module est un outil, pas un substitut de compréhension. Utilisez‑le pour simplifier le code, mais conservez l’architecture mentale du format. Ce code est minimal, mais il montre une API stable. L’important est la clarté du flux : ouvrir, écrire, lire, fermer. Étape 10 : persistance et sécurité Une base key‑value est souvent utilisée pour stocker des données critiques. Même dans un projet simple, vous devez penser à la sécurité du stockage. La persistance ne se limite pas à écrire dans un fichier, elle inclut la capacité à survivre à un crash. Une stratégie simple est d’écrire des entrées avec un checksum et d’ignorer celles qui sont invalides. Ce n’est pas compliqué, mais c’est essentiel. Étape 11 : design et discipline Le point central est la discipline. Une base key‑value simple peut rester fiable si vous respectez trois règles : format stable, erreurs explicites, et compaction contrôlée. Ces règles sont plus importantes que n’importe quelle optimisation. La base la plus rapide ne vaut rien si elle est incompréhensible. Conclusion Vous avez construit une base key‑value simple, mais robuste. Vous avez appris à définir un format, à gérer l’I/O, à construire un index, et à compacter. Plus important encore, vous avez appris à rendre les erreurs visibles et à protéger la cohérence du stockage. Ce projet est un modèle de discipline : vous privilégiez la clarté et la stabilité, et c’est exactement ce qui rend un système utilisable à long terme. Étape 12 : journalisation (write‑ahead log) La journalisation est une technique simple qui améliore la robustesse. Avant d’écrire dans le fichier principal, vous écrivez l’opération dans un journal. Si un crash arrive, vous rejouez le journal pour restaurer la cohérence. Cela peut sembler complexe, mais l’idée est simple : une opération n’est considérée “faite” que si le journal l’a enregistrée. Dans un projet pédagogique, un WAL minimal peut être un fichier append‑only où chaque ligne représente une opération ou . Au démarrage, vous relisez ce fichier et vous appliquez les opérations dans l’ordre. Ensuite, vous pouvez effacer le journal. Cette technique introduit une discipline de fiabilité qui est largement utilisée dans les systèmes sérieux. Étape 13 : transactions (logiques) Les transactions permettent de regrouper plusieurs opérations en un tout cohérent. Même si vous n’implémentez pas un système complet, vous pouvez simuler un “begin/commit”. L’idée est de retenir les opérations dans un buffer, puis de les écrire en bloc. Si le programme échoue avant le commit, rien n’est écrit. Cette approche réduit le risque d’état partiel. Pour un projet simple, une transaction peut être une liste d’opérations en mémoire. Si la transaction est abandonnée, la liste est simplement ignorée. Si elle est commitée, les opérations sont écrites dans l’ordre. Étape 14 : snapshots Un snapshot est une photo cohérente de la base à un instant donné. Il permet de sauvegarder un état stable, puis de revenir à cet état en cas de besoin. Dans une base append‑only, un snapshot peut être un fichier compacté complet. Il sert de point de départ pour la reconstruction. Même si vous n’implémentez pas un système de snapshots sophistiqué, la simple capacité à générer un fichier propre est déjà un snapshot. La clé est de le rendre reproductible et documenté. Étape 15 : compaction incrémentale La compaction complète peut être coûteuse sur de gros fichiers. Une compaction incrémentale consiste à déplacer une partie du fichier à la fois, ou à compacter une tranche définie. Cette technique est plus complexe, mais elle permet d’éviter des pauses longues. Dans un projet simple, vous pouvez simuler une compaction partielle en traitant un nombre fixe d’entrées par cycle. Cette approche donne une base conceptuelle pour des systèmes plus avancés. Étape 16 : projets d’extension Voici quelques extensions concrètes, chacune représentant un mini‑projet complet. L’objectif est d’apprendre en ajoutant une fonctionnalité claire et isolée. Un premier projet consiste à ajouter des TTL (time‑to‑live). Une clé expire après un délai. Cela nécessite d’enregistrer un timestamp et d’ignorer les entrées expirées lors de la lecture. Un deuxième projet consiste à ajouter une commande qui liste toutes les clés avec un préfixe donné. C’est utile pour explorer la base et tester l’index. Un troisième projet consiste à ajouter un checksum par entrée. Cela vous oblige à écrire une fonction de hash et à rejeter les entrées corrompues. Un quatrième projet consiste à ajouter un mini protocole réseau, pour accéder à la base via TCP. Cela introduit une nouvelle frontière, utile pour apprendre l’architecture système. Ces projets sont volontairement séparés. Chacun peut être développé indépendamment, ce qui vous permet d’expérimenter sans casser l’ensemble. Étape 17 : WAL en pseudo‑code (concept minimal) Ce pseudo‑code illustre un journal minimal. L’idée est d’écrire chaque opération dans un fichier de journal, puis de la rejouer au démarrage. Ce modèle est simple, mais il capture l’essentiel. Une opération est durable parce qu’elle est journalisée, pas parce qu’elle a été appliquée. Étape 18 : tests de corruption Tester la corruption est plus utile que tester le cas nominal, parce que c’est là que les bugs détruisent des données. Une stratégie simple consiste à tronquer volontairement le fichier et à vérifier que la base refuse de lire au‑delà de ce qui est valide. Un test de corruption peut aussi inverser quelques bytes et vérifier que le checksum échoue. Même si vous n’avez pas encore de checksum, le test vous force à réfléchir à la détection d’erreurs. Cette discipline est la différence entre un projet pédagogique et un projet robuste. Étape 19 : plan de tests complet Un plan de tests complet couvre le nominal et le non‑nominal. Il ne s’agit pas d’avoir des centaines de tests, mais de couvrir les scénarios qui cassent réellement les bases key‑value. Commencez par un test simple : écrire une clé, lire, comparer. Ajoutez ensuite un test de suppression, puis un test qui réécrit une clé avec une nouvelle valeur. Ces tests garantissent la cohérence de l’append‑only. Ensuite, testez la reconstruction de l’index après redémarrage : écrivez, fermez, rouvrez, relisez. Enfin, ajoutez un test de corruption pour vérifier que les erreurs sont détectées. Ce plan est court, mais il couvre les risques majeurs. Un plan trop long est souvent un plan non exécuté. Étape 20 : benchmark simple Le benchmarking doit rester pragmatique. Mesurez d’abord le temps d’écriture d’un lot de clés, puis le temps de lecture aléatoire. Le but n’est pas d’obtenir des chiffres absolus, mais de voir si une modification améliore ou dégrade le comportement. Un benchmark simple consiste à écrire 10 000 entrées, puis à lire 1 000 clés aléatoires. Mesurez le temps total, puis comparez après une modification. Cette méthode donne un signal clair sans instrumentation complexe."
  },
  {
    "title": "'25. Projet 5 : embarqué Arduino (étape par étape)'",
    "url": "/book/25-projet-arduino/",
    "text": "25. Projet 5 : embarqué Arduino (étape par étape) Le monde embarqué impose des contraintes fortes. C’est exactement le terrain où la clarté du code fait la différence. Un microcontrôleur n’a pas la marge d’un serveur, et il ne pardonne pas les abstractions inutiles. Ce chapitre est un guide détaillé, étape par étape, en gros paragraphes continus, pour construire un programme Arduino minimal mais fiable, puis pour l’étendre sans perdre la lisibilité. L’objectif n’est pas de “faire beaucoup”, mais de faire juste, propre, et reproductible. Étape 0 : état d’esprit Commencez par accepter trois réalités. La mémoire est limitée, le CPU est lent, et le diagnostic est difficile. Cela signifie que chaque ligne doit avoir une raison d’exister, et que chaque ajout doit être justifié par un bénéfice clair. Le code embarqué est un code de discipline. Cette discipline n’est pas une contrainte “morale”, c’est la condition qui rend le projet maintenable. Étape 1 : cahier des charges minimal Nous allons écrire un programme qui fait clignoter une LED. Ce cahier des charges est volontairement modeste, mais il contient tout ce qu’il faut pour apprendre : initialiser un périphérique, appliquer un timing stable, et conserver un flux lisible. Un cahier des charges clair est le meilleur test de lisibilité. Si vous n’arrivez pas à décrire le programme en une phrase, vous ne pourrez pas le maintenir. Étape 2 : structure minimale du fichier Un projet embarqué doit commencer par une structure simple. Un seul fichier, quelques imports explicites, des constantes visibles, des fonctions courtes, puis l’entrée. Cette structure évite de “l’architecture prématurée”. Vous ne gagnez rien à disperser le code si vous n’avez pas encore un besoin réel de séparation. En revanche, vous gagnez beaucoup à garder un ordre lisible. Étape 3 : premiers imports et constantes La première décision concrète est d’importer les modules Arduino nécessaires. Nous utilisons le module GPIO et le module timer. Ensuite, nous définissons une constante pour le pin de la LED. Cette constante rend la configuration visible et réduit les erreurs d’édition. L’important ici n’est pas la syntaxe, mais l’intention. Une constante explicite est plus lisible qu’un perdu au milieu d’un flux. Étape 4 : entrée minimale Nous écrivons l’entrée la plus simple possible. Elle configure la pin en sortie, puis alterne état haut et bas avec un délai. Ce flux est la base de presque tous les programmes embarqués : initialiser, puis boucler. Ce code est volontairement explicite. Chaque action est visible. Vous savez exactement ce que fait le programme, et dans quel ordre. Ce niveau de clarté est un objectif, pas un hasard. Étape 5 : stabiliser le timing Un clignotement stable est un test de fiabilité. Si vous observez des variations, votre boucle fait probablement plus que ce que vous pensez. La correction est rarement une optimisation : c’est une simplification. Vérifiez que votre boucle n’a qu’une seule responsabilité. Évitez d’ajouter du code “au hasard” dans la boucle principale. Chaque ajout doit être justifié. Étape 6 : paramétrer sans compliquer La prochaine étape consiste à rendre la durée configurable. La règle est simple : un paramètre, une constante. Vous pouvez introduire et remplacer les par cette constante. Le gain est minime en code, mais majeur en lisibilité. L’utilisateur et le futur mainteneur voient immédiatement où modifier le comportement. Étape 7 : factoriser l’action Quand le flux devient répétitif, vous pouvez factoriser. Mais factoriser n’est pas toujours un gain en embarqué. Le bon moment est celui où la factorisation rend la logique plus claire, pas celui où elle rend le code plus “joli”. Une fonction peut être utile si elle clarifie le flux. Si elle ajoute une couche sans gain, évitez‑la. Étape 8 : gérer l’état explicitement Si vous ajoutez un bouton, un capteur, ou un mode de clignotement alternatif, vous introduisez un état. Cet état doit être explicite, visible, et stable. Un est souvent plus clair que deux booléens. Cette étape est cruciale, car elle marque le passage d’un flux linéaire à un flux conditionnel. Étape 9 : éviter les allocations inutiles L’embarqué ne tolère pas les allocations dynamiques inutiles. Si vous n’avez pas besoin d’un buffer dynamique, n’en créez pas. Les allocations augmentent la fragmentation et rendent le comportement plus difficile à prévoir. Cette discipline n’est pas “exagérée”, elle est essentielle. Étape 10 : version opérationnelle À ce stade, votre programme est fonctionnel et lisible. Une version opérationnelle ne signifie pas “feature‑complete”, elle signifie “comportement stable et explicable”. Si vous pouvez expliquer le flux sans regarder le code, vous avez réussi. Étape 11 : variantes contrôlées Une variante utile consiste à rendre le clignotement configurable par un input (bouton). Une autre variante consiste à introduire un mode “diagnostic” avec un pattern de LED différent. Ces variantes doivent être ajoutées une par une, avec un changement minimal à chaque étape. L’objectif est de conserver un système lisible malgré l’évolution. Étape 12 : erreurs fréquentes et corrections Les erreurs les plus fréquentes en embarqué sont des erreurs de structure. Trop d’abstraction, pas assez de visibilité. D’autres erreurs classiques : oublier de configurer une pin, mélanger la logique de timing et de lecture d’entrée, ou disperser les décisions dans plusieurs fonctions. La correction est toujours la même : rendre le flux explicite, réduire les niveaux d’indirection, et centraliser les décisions. Conclusion Ce projet n’est pas un gadget. Il vous apprend une discipline : écrire moins, mais écrire mieux. L’embarqué impose des contraintes que beaucoup de développeurs ignorent. Ces contraintes peuvent devenir des forces, si vous acceptez la simplicité comme un outil de qualité. Un programme embarqué n’a pas besoin d’être complexe pour être sérieux. Il a besoin d’être clair, stable, et explicable. C’est exactement ce que vous avez construit étape par étape. Étape 13 : capteurs, I2C, SPI, gestion d’énergie À partir du moment où vous connectez un capteur, vous quittez le monde du simple GPIO. Vous entrez dans un monde de protocoles et de timing. Cela ne signifie pas “complexité gratuite”, cela signifie “discipline renforcée”. La bonne approche est de traiter chaque protocole comme un module séparé, avec des responsabilités claires et un flux lisible. Capteurs et lecture robuste Un capteur n’est jamais stable. Il renvoie parfois des valeurs hors plage, parfois des erreurs. Le code embarqué doit donc traiter la lecture comme une opération potentiellement invalide. La règle simple est d’introduire un contrôle après chaque lecture, même si vous ne le faites pas encore en profondeur. L’objectif est de préparer le terrain à la robustesse. I2C : protocole partagé, discipline nécessaire I2C est un bus partagé. Cela signifie que plusieurs périphériques communiquent sur les mêmes lignes. La logique doit donc être claire : initialiser le bus, sélectionner un périphérique, envoyer une commande, lire une réponse. Une lecture I2C est un mini‑contrat. Si vous oubliez une étape, vous obtenez un comportement silencieux et frustrant. Voici un exemple avec un capteur BH1750, disponible dans la stdlib Arduino. Il montre une séquence simple : initialiser le bus, créer le capteur, puis lire une valeur. Ce code est volontairement explicite. Même si l’exemple ne gère pas toutes les erreurs, il donne la structure correcte : init, config, loop de lecture. L’étape suivante consiste à ajouter des contrôles d’erreur et un filtrage simple des valeurs. SPI : vitesse et discipline SPI est plus rapide que I2C, mais il exige une gestion stricte du chip select. Le risque principal est d’envoyer une séquence de bytes sans cadrer correctement le périphérique. La solution est d’encapsuler la séquence SPI dans une fonction dédiée, et d’éviter de disperser les appels dans le code. Cet exemple est minimal, mais il illustre la discipline : ouverture, transfert, fermeture. Dans un projet réel, vous ajouteriez un contrôle de vitesse, un timing, et une gestion d’erreur. Gestion d’énergie : ressource invisible Sur une carte embarquée, l’énergie est une ressource. Si vous voulez un programme fiable sur batterie, vous devez réduire les cycles actifs. La règle est de minimiser les boucles actives et d’utiliser des délais ou des modes basse consommation quand c’est possible. Même sans API complète de power management, vous pouvez réduire la consommation en diminuant la fréquence de lecture et en évitant les calculs inutiles. Une discipline simple est d’introduire un cycle “mesure → attente”. Par exemple, lire un capteur, traiter, puis dormir. Cette structure se comprend immédiatement et rend l’énergie visible dans le flux du programme. Conclusion de l’étape Capteurs, I2C, SPI et gestion d’énergie sont des sujets différents, mais ils partagent une même règle : l’explicite est votre allié. Si vous rendez les séquences de communication visibles et séparées, votre code devient robuste. Si vous les mélangez, vous créez un système opaque. L’embarqué ne pardonne pas l’opacité. Étape 14 : pipeline complet “capteur → filtre → affichage” Cette étape construit une chaîne complète, du capteur jusqu’à une sortie visible. Même si l’embarqué n’a pas toujours de console, il a souvent un canal d’affichage minimal, comme un port série. L’objectif est de montrer une structure complète : lecture, filtrage, puis émission d’un résultat. Cette discipline est la même quel que soit le capteur. Nous allons lire un capteur I2C, appliquer un filtre très simple, puis envoyer la valeur via le port série. Le filtre est volontairement basique : une moyenne glissante sur quelques mesures. Le but n’est pas de faire des mathématiques avancées, mais d’illustrer la structure. Cet exemple montre une pipeline complète. Il reste volontairement simple, mais la structure est celle d’un projet réel : acquisition, filtrage, émission. Le filtrage empêche les valeurs erratiques de dominer, et la sortie série donne un feedback minimal mais utile. Étape 15 : debug embarqué sans console Le debug embarqué est une discipline particulière, parce que vous n’avez pas la console confortable d’un OS. Cela ne signifie pas “pas de debug”, mais “debug par signes”. Les signes sont des LEDs, des timings, des séquences, et parfois un port série minimal. La première technique est le clignotement codé. Vous encodez des états avec des patterns de LED. Par exemple, un clignotement lent signifie “ok”, un clignotement rapide signifie “erreur I2C”. Ce n’est pas élégant, mais c’est très fiable. La seconde technique est le “heartbeat”. Un clignotement stable, régulier, vous dit que le firmware tourne encore. Si le heartbeat s’arrête, vous savez immédiatement qu’une erreur bloquante s’est produite. La troisième technique est l’utilisation du port série, même en mode minimal. Vous pouvez envoyer des octets bruts qui servent de signaux. Par exemple, envoyer pour “capteur ok”, pour “capteur absent”. Cette approche est primitive, mais elle donne un canal de diagnostic concret. Enfin, la meilleure méthode reste la réduction du problème. Quand un bug apparaît, supprimez tout ce qui n’est pas nécessaire, gardez une seule lecture de capteur, et vérifiez que la chaîne fonctionne. Cette discipline de réduction est la clé du debug embarqué. Étape 16 : gestion des erreurs I2C/SPI Les bus I2C et SPI sont fiables, mais pas parfaits. Les erreurs existent : périphérique absent, bus saturé, données incohérentes. En embarqué, le silence est dangereux. La meilleure stratégie est d’ajouter un traitement d’erreur minimal et visible, même si vous ne faites pas encore de récupération complexe. Pour I2C, la règle est simple : chaque lecture doit pouvoir échouer, et cette possibilité doit être reflétée dans le flux. Si l’API ne renvoie pas explicitement une erreur, vous pouvez introduire un contrôle par valeurs plausibles. Par exemple, si un capteur renvoie une valeur hors plage, vous la rejetez et vous gardez la dernière valeur valide. Ce n’est pas parfait, mais c’est déjà une barrière contre les comportements erratiques. Pour SPI, la discipline se situe surtout dans la séquence. Commencez, transférez, terminez. Si vous mélangez des transferts sans séparation, vous créez des erreurs difficiles à diagnostiquer. La correction n’est pas un “hack”, c’est un retour à une séquence claire. Une approche simple consiste à définir des codes d’état, puis à refléter ces codes par un signal visuel. Par exemple, une LED qui clignote deux fois signifie “erreur I2C”, trois fois signifie “erreur SPI”. Ce type de signal n’est pas élégant, mais il est extrêmement utile quand vous n’avez pas de console. Étape 17 : calibration des capteurs Un capteur brut n’est pas un capteur utile. La calibration consiste à ajuster les valeurs brutes pour qu’elles correspondent à une réalité physique. Le principe est simple : mesurer un point de référence, calculer un facteur, appliquer ce facteur à toutes les mesures suivantes. Cette logique peut être aussi simple que deux constantes, mais elle doit être explicite dans le code. Une calibration minimale comprend un “offset” et un “scale”. L’offset corrige un décalage constant, le scale corrige une proportion. Même si vous ne faites pas de calibration scientifique, ce modèle améliore la lisibilité et prépare votre code à des ajustements futurs. En pratique, vous pouvez stocker ces paramètres dans des constantes, ou les charger depuis une configuration simple si votre environnement le permet. L’important est de garder la calibration visible et modifiable. Un calibrage caché est un bug latent. Étape 18 : stockage persistant (EEPROM/flash) À un moment, vous voudrez garder un réglage entre deux redémarrages. C’est exactement le rôle de la mémoire persistante, comme l’EEPROM ou la flash. L’embarqué n’offre pas le confort d’un système de fichiers, donc la persistance doit être pensée avec parcimonie. La règle d’or est de limiter les écritures, car la mémoire flash s’use. La stratégie minimale consiste à définir une petite structure de configuration, à l’écrire rarement, et à la relire au démarrage. Même si vous n’avez pas encore une API complète dans la stdlib, l’idée reste la même : un bloc de données stable, une fonction de lecture, une fonction d’écriture, et un checksum simple si possible. Le checksum n’est pas un luxe, c’est une barrière contre les corruptions silencieuses. Un bon usage de la persistance est de stocker des paramètres d’étalonnage, un mode utilisateur, ou un dernier état connu. Mais il faut éviter d’écrire à chaque boucle. Un microcontrôleur qui écrit en permanence sur la flash finira par perdre la mémoire. La persistance est une ressource, pas un flux. Étape 19 : scheduling simple (timer + boucle) Le scheduling en embarqué n’a pas besoin d’un RTOS pour être efficace. Un modèle simple “timer + boucle” suffit pour beaucoup d’applications. L’idée est de découper votre boucle principale en tâches, chacune avec sa propre cadence. Vous ne lancez pas une tâche à chaque itération, vous la lancez quand son timer l’autorise. La structure classique est la suivante : vous lisez l’heure courante, vous comparez avec un timestamp, puis vous exécutez si le délai est passé. Cette approche est prévisible et facile à tester. Elle évite les bloquants, ce qui rend le programme plus réactif. Même sans API complète, vous pouvez simuler cette logique avec des compteurs et des délais. L’important est d’être explicite sur les cadences : “lire le capteur toutes les 1000 ms, clignoter toutes les 200 ms”. Un scheduling clair est la base d’un système embarqué robuste. Étape 20 : exemple concret de persistance (calibration) Voici une manière simple de penser la persistance d’un calibrage. L’idée est de stocker un offset et un scale, puis de les appliquer à chaque lecture. Le code exact dépend de l’API disponible, mais la structure conceptuelle est stable. Vous lisez la configuration au démarrage, vous appliquez, et vous réécrivez uniquement quand l’utilisateur change le calibrage. Même si vous ne disposez pas d’un module EEPROM dans la stdlib, ce modèle guide votre implémentation. L’important est de rendre l’état persistant visible, et de limiter les écritures. Un calibrage écrit une fois par session est raisonnable ; un calibrage écrit à chaque boucle est dangereux. Étape 21 : scheduling simple en pseudo‑code Vitte Ce pseudo‑code montre une boucle principale qui exécute deux tâches à des cadences différentes. Le principe est de stocker le dernier timestamp de chaque tâche, puis de comparer avec l’horloge courante. Cette forme est simple, lisible, et extensible. Elle évite les bloquants et rend le programme plus réactif. Étape 22 : state machine pour les tâches Quand un programme embarqué devient plus complexe, une simple boucle avec des timers peut être insuffisante. Une machine à états rend le flux explicite. Vous définissez des états stables et des transitions claires. Cela réduit les “if” imbriqués et rend le comportement prévisible. Une machine à états simple pourrait gérer un cycle “init → read → process → sleep”. Chaque état fait une chose, puis passe explicitement au suivant. Le code devient plus long, mais beaucoup plus facile à comprendre et à déboguer. Étape 23 : tests embarqués sans matériel Tester sans matériel est possible, mais il faut accepter un modèle simplifié. Vous pouvez simuler des capteurs en injectant des valeurs dans une fonction de lecture, ou créer un “driver” faux qui renvoie des valeurs prédictibles. L’objectif est de tester la logique, pas l’électronique. Cette approche vous donne un filet de sécurité. Quand vous branchez enfin le matériel, vous savez déjà que la logique est correcte. Vous ne dépendez plus du hasard ou de l’intuition. Étape 24 : machine à états en pseudo‑code Vitte Ce pseudo‑code illustre une machine à états simple. L’objectif est de rendre les transitions explicites. Chaque état fait une chose, puis choisit le prochain état. Cette structure est un excellent outil quand le flux devient trop complexe pour une simple boucle. Étape 25 : plan de tests simulés (étape par étape) Un plan simple permet de valider la logique sans matériel. Vous injectez des valeurs connues, puis vous observez la sortie attendue. Première étape : simuler une lecture stable et vérifier que le filtre ne modifie pas la valeur. Deuxième étape : injecter une valeur hors plage et vérifier qu’elle est rejetée. Troisième étape : simuler une séquence de lectures et vérifier que la moyenne glissante est correcte. Quatrième étape : simuler un capteur absent et vérifier que l’état “erreur” est atteint. Cinquième étape : simuler un retour à la normale et vérifier que le système récupère. Ce plan n’est pas long, mais il couvre la majorité des bugs logiques. Il vous donne une base solide avant de passer au matériel. Étape 26 : profiling embarqué (simple et fiable) Le profiling embarqué n’a pas besoin d’outils complexes. Une méthode simple consiste à mesurer des durées avec ou et à comparer les temps avant et après une section critique. L’objectif n’est pas la précision absolue, mais la compréhension relative : quelles parties de votre boucle coûtent le plus. Un profiling minimal peut être réalisé en insérant des timestamps autour d’une fonction. Vous enregistrez la différence et vous l’émettez via un canal simple, comme la LED ou le port série. Même un chiffre approximatif vous aide à décider où optimiser. Étape 27 : gestion d’interruptions (concepts essentiels) Les interruptions sont puissantes, mais dangereuses si elles sont mal utilisées. Une interruption doit être courte, rapide, et déterministe. Elle ne doit jamais contenir de logique complexe ou de blocage. Son rôle est de signaler qu’un événement est arrivé, pas de traiter tout l’événement. Une stratégie saine est de définir un flag dans l’interruption, puis de traiter ce flag dans la boucle principale. Cela maintient la logique principale dans un flux lisible et évite les effets de bord imprévisibles. Ce modèle est une discipline, et c’est exactement ce qui rend un code embarqué stable. Étape 28 : debounce (anti‑rebond) Les boutons mécaniques rebondissent. Cela signifie qu’un seul appui peut être lu comme plusieurs appuis. La correction n’est pas un détail, c’est une nécessité pour éviter un comportement erratique. La méthode la plus simple consiste à ignorer les changements pendant une fenêtre temporelle courte après la première détection. Le principe est de privilégier la fiabilité sur la réactivité extrême. Même sans implémentation complète, l’idée est claire : vous lisez l’état, vous notez le temps, et vous n’acceptez pas un nouveau changement tant que le délai minimal n’est pas passé. Ce modèle protège la logique de vos états et évite des bugs très difficiles à diagnostiquer. Étape 29 : watchdog (redémarrage contrôlé) Un watchdog est un mécanisme de sécurité. Si votre code se bloque, le watchdog redémarre le système. Cela peut sembler brutal, mais c’est souvent la meilleure stratégie sur un microcontrôleur. Le but n’est pas d’éviter tous les bugs, mais de garantir une récupération automatique quand un bug survient. La discipline du watchdog est simple : vous “nourrissez” régulièrement le watchdog dans une boucle saine. Si la boucle se bloque, le watchdog déclenche un reset. Ce mécanisme doit être clair dans le code, afin que chaque mainteneur comprenne pourquoi un reset peut se produire. Étape 30 : bootloader et mise à jour de firmware Le firmware n’est pas immuable. En pratique, vous devrez corriger des bugs ou ajouter des fonctionnalités. Cela implique une stratégie de mise à jour. Sur Arduino, vous utilisez souvent un bootloader existant, mais il est important de comprendre la logique : le bootloader est un petit programme qui charge le firmware réel. Une bonne pratique consiste à garder un processus de mise à jour simple, documenté, et reproductible. La mise à jour est un moment de risque : si elle échoue, le système peut être inutilisable. Ce risque impose une discipline de build et de tests, même sur un projet “simple”. Étape 31 : sécurité électrique (pragmatique) Le logiciel n’est pas isolé du matériel. Une erreur électrique peut détruire un capteur, ou pire, rendre votre diagnostic impossible. Cela signifie que la discipline logicielle doit être accompagnée d’une discipline matérielle. Utiliser des résistances adaptées, respecter les niveaux de tension, et éviter les courts‑circuits est une condition de réussite. Même si vous êtes côté logiciel, vous devez comprendre ces contraintes. Sur le plan logiciel, cela se traduit par une prudence de configuration. Par exemple, éviter de configurer une pin en sortie si elle est câblée sur un bus partagé, ou éviter d’activer des modes qui mettent le matériel en conflit. La sécurité électrique est aussi une question de séquence : initialiser d’abord, puis activer, jamais l’inverse. Étape 32 : diagnostic en production Quand un firmware est déployé, vous n’avez plus de terminal ni d’IDE. Le diagnostic doit donc être pensé en amont. La stratégie la plus simple est de réserver un canal de signalisation. Une LED peut être suffisante. Un port série minimal peut suffire. L’essentiel est d’avoir un signal stable qui indique l’état général et les erreurs critiques. Un diagnostic en production n’a pas besoin d’être verbeux, il doit être fiable. Un code d’erreur succinct est préférable à un message long et fragile. L’objectif est de permettre une récupération rapide, même sans outils sophistiqués."
  },
  {
    "title": "'26. Projet 6 : éditeur de code en terminal'",
    "url": "/book/26-projet-editor/",
    "text": "26. Projet 6 : éditeur de code en terminal Ce chapitre est un tutoriel long, narratif, et volontairement pédagogique. L’objectif n’est pas de battre ou , mais de comprendre ce qu’implique un éditeur en terminal. Vous allez construire un “éditeur minimal” qui ouvre un fichier, affiche les lignes, permet de déplacer un curseur, d’insérer du texte, et d’enregistrer le résultat. Chaque étape est un petit contrat entre votre code et l’utilisateur. Ce projet est important parce qu’il combine tout ce que vous avez appris : I/O, parsing, état interne, gestion d’erreurs, et clarté du flux. Il est aussi parfait pour pratiquer une règle simple : un éditeur qui perd des données est un bug impardonnable. Note éditoriale (style O’Reilly) Un projet comme celui-ci se juge à la qualité de son récit. Chaque étape doit dire trois choses : ce que l’on fait, pourquoi on le fait, et comment on saura que c’est correct. Si une section ne respecte pas ces trois questions, elle est trop courte ou trop technique. Gardez en tête que vous écrivez pour un lecteur intelligent mais occupé. Il veut comprendre vite, mais il ne veut pas deviner. Prérequis et contraintes Dans l’état actuel de la stdlib, nous disposons d’outils bas niveau (lecture/écriture, buffers, terminal minimal). Nous ne disposons pas encore d’un mode “raw” complet qui désactive l’écho et les raccourcis du terminal. Nous allons donc construire un éditeur « ligne par ligne » qui fonctionne en mode standard. Le projet reste pertinent : il vous apprend à structurer l’état, la logique de rendu, et la persistance. À la fin du chapitre, vous aurez aussi une version “API idéale” qui montre comment vous adapter lorsque le mode raw sera disponible. Étape 1 : définir le contrat utilisateur Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Avant d’écrire du code, écrivez le contrat en une page. Un éditeur terminal minimal doit répondre à quatre questions simples : Comment ouvrir un fichier ? Comment se déplacer ? Comment modifier ? Comment sauvegarder ? Pour rester réaliste, nous choisissons un ensemble minimal de commandes textuelles : ouvre un fichier. affiche les lignes avec numéros. insère une ligne. supprime une ligne. enregistre. quitte. Ce choix n’est pas “moderne”, mais il est robuste et compatible avec les APIs existantes. La clarté d’abord. Étape 2 : modèle de données Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Un éditeur, c’est d’abord un état. Nous avons besoin : d’un chemin de fichier (optionnel),. d’un tableau de lignes,. d’un indicateur “modifié” pour savoir si on doit prévenir l’utilisateur. Nous allons utiliser une structure simple. Le but est que chaque champ ait une responsabilité unique. L’état est crucial. Il n’est pas décoratif. Il représente un contrat moral : ne jamais perdre un travail non sauvegardé. Étape 3 : chargement du fichier Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Dans un monde idéal, on lirait tout le fichier en mémoire et on le découperait en lignes. La stdlib fournit des primitives pour lire un flux, et un buffer pour lire ligne par ligne. Nous allons utiliser et . L’approche est simple : Ouvrir le fichier en lecture. Lire ligne par ligne. Stocker chaque ligne dans . Fermer le fichier. Le code suivant est volontairement clair, sans optimisation prématurée. Notez l’usage de . Les erreurs doivent être visibles pour l’utilisateur, et séparées de la sortie normale. Étape 4 : affichage Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Un éditeur sans affichage n’est qu’un parseur. Nous allons écrire une fonction qui affiche chaque ligne avec son numéro. Cette étape semble triviale, mais elle définit le format que l’utilisateur va apprendre à reconnaître. La règle : le format doit être stable et lisible. Un utilisateur doit pouvoir lire “3: let x = 1” et comprendre immédiatement qu’il s’agit de la ligne 3. Si n’est pas disponible pour votre type, remplacez‑le par une conversion manuelle ou un petit helper. L’important n’est pas la conversion, mais la stabilité de la sortie. Étape 5 : parser des commandes Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Nous allons maintenant lire des commandes ligne par ligne. Le protocole est simple : une ligne d’entrée est une commande. Le parsing est naïf : on découpe par espaces, on prend le premier mot comme verbe. Cette approche a deux avantages : Elle est simple à expliquer. Elle est suffisamment robuste pour ce projet. Dans un projet réel, on utiliserait un parseur plus strict, mais ici la clarté est l’objectif. L’important n’est pas l’algorithme, mais le contrat : une commande = un verbe + des arguments. Étape 6 : insertion et suppression Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. L’insertion consiste à insérer une ligne à un index donné. La suppression consiste à retirer une ligne. Ce sont deux opérations qui semblent simples, mais qui provoquent la majorité des bugs d’index. Règle simple : valider les indices, toujours. Un sur un fichier de 10 lignes doit être rejeté proprement. Le code ci‑dessus est volontairement clair et verbeux. Un éditeur est un lieu où la simplicité est un avantage. Étape 7 : sauvegarde Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. La sauvegarde doit être fiable, même si elle est lente. Le principe minimal : Ouvrir le fichier en écriture. Écrire chaque ligne + un . Fermer le fichier. En l’absence d’un API de “write text file” haut niveau, nous allons simplement décrire la logique. Si vous avez accès aux primitives d’écriture ( ), adaptez le code. L’important est de comprendre le flux. Étape 8 : boucle principale Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. L’éditeur est une boucle : Lire une commande. Exécuter. Afficher si nécessaire. Cette boucle doit être lisible. Elle est la pièce maîtresse de l’éditeur. Étape 9 : gestion des erreurs Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Un éditeur ne doit jamais perdre de données. Ajoutez une confirmation quand et que l’utilisateur demande . C’est une règle morale, pas un détail technique. Étape 10 : améliorer la lisibilité Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Même dans un projet simple, ajoutez des paragraphes de documentation dans le code. Un éditeur est un outil de lecture ; il mérite un code lisible. API idéale (future) Quand le mode raw et la gestion fine du terminal seront disponibles, vous pourrez ajouter : Mouvement de curseur en temps réel. Rendu plein écran. Recherche incrémentale. Undo/redo. Ce chapitre vous prépare à ces étapes : vous avez déjà séparé l’état, le rendu, et la logique. Conclusion Vous avez construit un éditeur minimal, lisible, et sûr. Ce n’est pas un exercice de performance, c’est un exercice de clarté. Un éditeur est un miroir : si votre code est confus, l’expérience utilisateur sera confuse. Vous avez donc appris une leçon essentielle : la lisibilité est une fonctionnalité. Étape 11 : parser robuste des commandes Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Jusqu’ici, nous avons décrit un parsing « à la main ». Nous allons maintenant écrire un parseur minimal mais complet : il découpe une ligne en mots, gère les espaces multiples, et renvoie un tableau de tokens. Ce n’est pas un parseur riche, mais c’est un parseur fiable. Il doit faire une chose et la faire bien : transformer une chaîne en arguments. Le principe est simple : avancer dans la chaîne, ignorer les espaces, puis capturer un mot jusqu’au prochain espace. Cette approche donne un comportement stable, prévisible, et facile à documenter pour l’utilisateur. Ce code est volontairement explicite. Le lecteur doit pouvoir comprendre la logique d’un coup d’œil. Le parsing n’est pas un lieu pour l’astuce. Étape 12 : sauvegarde réelle (API actuelle) Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Un éditeur existe pour sauver des modifications. Nous allons maintenant écrire une sauvegarde réelle, basée sur les APIs existantes. La règle est simple : écrire les lignes une par une, en ajoutant un à chaque ligne, puis fermer correctement le fichier. Cela donne un résultat stable et compatible avec les outils classiques. Cette version est lente pour de très gros fichiers, mais elle est robuste. Et c’est exactement ce que nous voulons dans un éditeur minimal : la fiabilité d’abord. Étape 13 : boucle complète (API actuelle) Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Nous avons maintenant tous les morceaux nécessaires. Il nous faut une boucle principale qui : lit une ligne de commande,. parse les mots,. applique l’action,. met à jour l’état. Voici une version claire et structurée : Ce code est long, mais il est lisible. Chaque commande est un bloc clair. Le lecteur peut suivre le flux sans effort. Dans un livre O’Reilly, la lisibilité est un objectif, pas une conséquence. Étape 14 : mode raw (API idéale) Dans cette étape, l’objectif est de transformer une idée en une règle simple et lisible. Quand un vrai mode raw sera disponible, vous pourrez remplacer la lecture « ligne par ligne » par une lecture caractère par caractère. Cela change toute l’expérience : le curseur peut bouger en temps réel, la ligne se redessine, l’éditeur se rapproche d’un outil moderne. Une version idéale inclurait : un mode raw activé au démarrage,. un qui réécrit tout l’écran,. un qui traite les flèches et l’insertion. L’architecture que vous avez construite reste valide : elle sépare l’état, le rendu, et la logique. C’est précisément la bonne base pour évoluer vers un éditeur complet. Conclusion Vous avez maintenant un éditeur terminal fonctionnel, même dans un environnement minimal. Vous avez appris que la qualité d’un éditeur ne se mesure pas au nombre de fonctionnalités, mais à la confiance qu’il inspire. Cette confiance vient d’une seule chose : un code clair, qui dit exactement ce qu’il fait. Petit helper pour les indices Pour convertir un argument de ligne en nombre, nous réutilisons un parseur simple. Il refuse les valeurs non numériques et renvoie en cas d’erreur. Code complet (version compacte) Ce bloc rassemble tout pour un éditeur minimal “ligne par ligne”. Il est volontairement long, mais chaque partie est lisible. Adaptez les détails selon les APIs exactes disponibles dans votre environnement. Mini‑framework d’UI terminal (API idéale) Ici, on bascule dans une approche “éditeur interactif”. Le but est de séparer l’UI en trois couches : l’état, le rendu, et l’entrée clavier. Même si l’API raw n’est pas encore disponible, le design est prêt. 1) État d’UI On ajoute un champ et un viewport : Le curseur est un état. Le viewport est un état. Cette séparation évite la confusion et rend l’affichage déterministe. 2) Rendu Le rendu doit être une fonction pure : “à partir de l’état, produire une sortie”. En mode raw, vous effacez l’écran et réécrivez tout. Pseudo‑code : Cette approche garantit que l’écran est toujours cohérent. La règle d’or : ne jamais dépendre d’un “état implicite” du terminal. 3) Entrée clavier L’entrée doit produire des événements : , , , etc. Chaque événement met à jour l’état. L’UI ne “dessine” pas directement, elle change l’état, puis le rendu s’applique. Pseudo‑code : 4) Barres et messages Une barre de statut est un élément clé d’un bon éditeur. Elle doit indiquer : le nom du fichier,. le nombre de lignes,. l’état “dirty”. Cette barre rend l’éditeur “parlant” et réduit les erreurs utilisateur. 5) Scrolling Le scrolling est l’un des premiers pièges. Vous devez l’implémenter explicitement : si le curseur sort du viewport, décalez le viewport. si le curseur remonte, remontez le viewport. Cette logique est purement mathématique. Elle est aussi la source de beaucoup de bugs subtils si elle est cachée. 6) Rendu incrémental (plus tard) Une fois tout stable, vous pourrez optimiser en ne redessinant que ce qui change. Mais ne faites pas cette optimisation trop tôt : la clarté prime. Conclusion Le mini‑framework d’UI vous donne la structure nécessaire pour évoluer vers un éditeur complet. Vous avez une base claire : état, rendu, entrée. Ce triptyque est la colonne vertébrale de tout éditeur terminal moderne. Erreurs courantes et diagnostics (édition terminal) Cette section est volontairement longue. Un éditeur terminal est une machine à bugs si vous ne prenez pas au sérieux les frontières entre l’état, l’entrée et la sortie. Les erreurs suivantes reviennent presque toujours, même chez des développeurs expérimentés. 1) Index hors bornes Symptôme : une insertion ou suppression casse l’ordre des lignes, ou provoque un crash silencieux. Cause : un index non validé, souvent parce qu’on fait confiance aux entrées utilisateur. La règle est simple : toute commande qui contient un index doit être validée. Si l’index est invalide, l’éditeur doit répondre avec un message explicite, pas un silence. Diagnostic : ajoutez un message d’erreur qui indique l’index reçu et la taille actuelle. Ce n’est pas une excuse, c’est un outil de compréhension. 2) Perte de données par omission Symptôme : l’utilisateur tape et perd son travail. Cause : le flag n’est pas mis à jour, ou la sortie n’est pas conditionnée à la sauvegarde. Ce bug est plus grave qu’un crash : il casse la confiance. Diagnostic : forcez une confirmation quand . Même un éditeur minimal doit respecter ce contrat moral. 3) Boucle principale illisible Symptôme : les commandes s’enchaînent avec des imbriqués et la logique devient opaque. Cause : on mélange parsing, exécution et affichage. Diagnostic : séparez “parser” et “exécuter”. Ajoutez une fonction qui ne fait qu’une chose. La lisibilité devient votre meilleur outil de debug. 4) Confusion entre stdout et stderr Symptôme : les erreurs se mélangent à la sortie normale, surtout quand l’éditeur est utilisé dans un script. Cause : on utilise pour tout. Diagnostic : utilisez pour les erreurs, pour la sortie normale. Ce n’est pas un détail : c’est une convention universelle. 5) Parser trop permissif Symptôme : une commande mal formée est interprétée comme autre chose. Cause : un parsing “au hasard”. Diagnostic : quand une commande est invalide, répondez avec un . Le but n’est pas de faire plaisir, mais de réduire les ambiguïtés. 6) Fichier ouvert mais jamais sauvegardé Symptôme : après plusieurs insertions, échoue en silence ou ne fait rien. Cause : vous avez oublié de stocker lors de . Diagnostic : assurez-vous que chaque commande qui ouvre un fichier met à jour . 7) Rendu incohérent (mode raw futur) Symptôme : le curseur saute, l’écran contient des artefacts. Cause : rendu partiel ou “incremental” sans cohérence globale. Diagnostic : en phase 1, redessinez tout l’écran à chaque étape. C’est plus lent, mais beaucoup plus robuste. 8) Scrolling mal géré Symptôme : le curseur disparaît hors écran, ou les lignes ne correspondent plus aux numéros. Cause : viewport non mis à jour. Diagnostic : maintenez un invariant explicite : doit toujours être dans . 9) Sauvegarde non atomique Symptôme : le fichier est partiellement écrit si un crash arrive au mauvais moment. Cause : écriture directe. Diagnostic : en version avancée, écrivez dans un fichier temporaire puis remplacez. Même un éditeur simple peut le faire. 10) Format de fichier “surprise” Symptôme : chaque ajoute une ligne vide ou change les fins de ligne. Cause : ajout systématique de sans vérifier l’état. Diagnostic : choisissez un format stable. Si vous forcez à la fin, dites-le clairement. La stabilité est préférable à la magie. **À retenir** Gardez la règle simple et visible. Une erreur doit être actionnable, pas silencieuse. La lisibilité est une fonctionnalité. Pas à pas par étapes (version narrative) Cette section présente un parcours chronologique, comme si vous écriviez l’éditeur par petites étapes cohérentes. Chaque étape est petite, explicable, et testable. C’est un excellent exercice de discipline : vous apprenez à découper un problème en livrables clairs. Étape 1 : squelette minimal Objectif : un programme qui compile et affiche un message. Ce commit ne fait rien d’utile, mais il établit la structure du projet. Étape 2 : structure Objectif : introduire l’état interne ( , , ). À ce stade, l’état ne sert à rien, mais il formalise la direction. Étape 3 : lecture d’un fichier Objectif : qui retourne des lignes. Ici, vous validez l’I/O et les erreurs de base. Étape 4 : affichage Objectif : afficher les lignes avec numéros. Vous formalisez le format de sortie. Étape 5 : parsing des commandes Objectif : + lecture d’une commande depuis stdin. Vous pouvez déjà écrire . Étape 6 : insertion et suppression Objectif : et fonctionnent et modifient l’état. Le flag est mis à jour. Étape 7 : sauvegarde Objectif : écrit réellement le fichier. Ici, la robustesse devient centrale. Étape 8 : sécurité de sortie Objectif : empêcher si . Ce commit protège l’utilisateur. Étape 9 : messages d’erreur propres Objectif : pour chaque commande invalide. Vous améliorez la “qualité de dialogue” de l’outil. Étape 10 : refactoring de la boucle Objectif : extraire ou des petites fonctions par commande. La lisibilité devient durable. Étape 11 : préparation au mode raw Objectif : séparer “rendu” et “entrée” dans la structure, même si l’implémentation reste ligne par ligne. Étape 12 : documentation finale Objectif : écrire un README court et stable qui explique l’usage. Un éditeur est aussi une documentation vivante. Chaque commit ci‑dessus peut être un mini‑chapitre. Le résultat final n’est pas seulement un éditeur : c’est une démonstration de méthode. Mode exercice (avec corrigés) Cette section propose des exercices guidés. Chaque exercice est formulé comme une petite mission, suivie d’un corrigé détaillé. Le but est de créer un vrai dialogue avec le lecteur, comme dans un manuel O’Reilly : l’exercice n’est pas un piège, c’est un outil d’apprentissage. Exercice 1 : index sûr **Mission** : modifiez et pour qu’elles renvoient un au lieu de silencieusement ignorer les indices invalides. **Pourquoi** : un échec silencieux est une dette. Un rend l’erreur visible et actionnable. **Corrigé (principe)** : introduisez un et renvoyez si l’index est invalide. Dans , affichez ce message sur . Exercice 2 : refuser les modifications sans fichier **Mission** : si aucun fichier n’a été ouvert, refusez et . **Pourquoi** : un éditeur minimal doit protéger l’utilisateur contre la confusion. Modifier sans fichier, c’est une erreur d’intention. **Corrigé (principe)** : vérifiez avant d’autoriser les modifications. Affichez un message clair. Exercice 3 : message de statut **Mission** : après chaque commande, affichez un message court qui indique l’état . **Pourquoi** : un éditeur “parle” à l’utilisateur. Ce feedback réduit les erreurs de sauvegarde. **Corrigé (principe)** : ajoutez une fonction qui affiche ou . Exercice 4 : mode lecture seule **Mission** : ajoutez une commande qui empêche toute modification. **Pourquoi** : cela vous force à centraliser les autorisations d’écriture. **Corrigé (principe)** : ajoutez un champ dans . Vérifiez ce champ avant / . Exercice 5 : undo simple **Mission** : implémentez un undo minimal, une seule étape. **Pourquoi** : l’undo est un excellent exercice d’état. Même une version simple améliore la confiance. **Corrigé (principe)** : gardez une copie des lignes avant chaque modification. Une commande remplace l’état courant. Tests manuels guidés (scénarios utilisateur) Ici, on remplace les “tests automatiques” par des scénarios humains. Pour un éditeur terminal, ces tests sont précieux. Ils vous apprennent à penser en termes d’expérience utilisateur, pas seulement d’API. Scénario 1 : ouverture et lecture Lancez l’éditeur. Tapez . Tapez . **Attendu** : les lignes du fichier apparaissent avec leur numéro. Le programme ne doit pas crasher si le fichier est vide. Scénario 2 : insertion simple . . . **Attendu** : la ligne 0 contient “Bonjour”. Le flag est vrai. Scénario 3 : suppression . . **Attendu** : la ligne 0 a disparu. Le flag est vrai. Scénario 4 : sauvegarde . Ouvrez le fichier dans un autre outil. **Attendu** : le contenu correspond à l’écran. Le flag revient à faux. Scénario 5 : sortie sécurisée Modifiez une ligne. Tapez . **Attendu** : le programme refuse de quitter et affiche un message d’avertissement. Scénario 6 : erreurs d’index . . **Attendu** : des messages d’erreur clairs, sans crash. Scénario 7 : fichier manquant . **Attendu** : un message d’erreur explicite, et aucun crash. Scénario 8 : usage incorrect . . . **Attendu** : chaque commande affiche . Scénario 9 : stress simple Insérez 50 lignes. Supprimez 25 lignes. Sauvegardez. **Attendu** : aucune corruption du fichier. Scénario 10 : redémarrage Sauvegardez. Quittez. Rouvrez le fichier. **Attendu** : l’état rechargé correspond aux modifications. Conclusion pédagogique Ces exercices et scénarios ne sont pas des annexes. Ils font partie du vrai apprentissage. Un éditeur est un outil où l’utilisateur doit faire confiance au logiciel. La confiance n’est pas un sentiment : c’est une conséquence de la rigueur. Si vous respectez ces exercices, vous respecterez vos utilisateurs. Erreurs avancées et recovery (protection des données) Un éditeur ne se juge pas seulement à ce qu’il fait quand tout va bien. Il se juge surtout à ce qu’il fait quand tout va mal. Cette section propose un niveau de robustesse supérieur, inspiré des pratiques des outils sérieux. 1) Sauvegarde atomique **Problème** : un crash au milieu de l’écriture peut laisser un fichier partiellement écrit. **Principe** : écrire dans un fichier temporaire, puis remplacer l’original. Sur la plupart des systèmes, un est atomique. Cela garantit qu’on ne voit jamais un fichier « moitié écrit ». **Approche** : Écrire dans . Fermer le fichier. Renommer → . Si l’étape 3 échoue, l’original reste intact. C’est exactement ce que l’on veut. 2) Fichier de secours (.bak) **Problème** : même avec une sauvegarde atomique, il est utile de garder une version précédente. **Principe** : avant de remplacer le fichier, faites une copie . Cela permet à l’utilisateur de récupérer une version antérieure si un bug d’éditeur survient. 3) Détection de corruption **Problème** : un fichier peut être corrompu (troncature, bytes invalides). Un éditeur naïf peut écraser un fichier déjà partiellement cassé. **Principe** : si l’ouverture du fichier déclenche une erreur, avertissez l’utilisateur et proposez une ouverture en mode “lecture seule” par défaut. 4) Journaling simple **Problème** : un crash pendant une session peut perdre des modifications non sauvegardées. **Principe** : journaliser chaque commande ( , ) dans un fichier . En cas de crash, on peut rejouer le journal. Même si ce mécanisme est simple, il réduit massivement les pertes de données. 5) Récupération au démarrage **Problème** : l’éditeur redémarre après un crash. Que faire du journal ? **Principe** : si un journal existe, l’éditeur propose de restaurer. Cette décision doit être explicite et visible. 6) Fichiers très grands **Problème** : charger tout en mémoire peut être impossible. **Principe** : passer en “mode streaming” ou “mode fenêtre”. L’éditeur ne charge qu’un bloc de lignes, et défile en rechargeant. Cette fonctionnalité est avancée, mais le design que vous avez (viewport, cursor) s’y prête naturellement. 7) Conflits externes **Problème** : le fichier est modifié par un autre outil pendant que vous éditez. **Principe** : stocker l’horodatage ou la taille initiale, puis avertir l’utilisateur si le fichier a changé. L’éditeur doit alors proposer une fusion ou un rechargement. **À retenir** Gardez la règle simple et visible. Une erreur doit être actionnable, pas silencieuse. La lisibilité est une fonctionnalité. Annexe : design UI terminal (schémas et flux) Cette annexe est volontairement “visuelle” dans un média texte. Les schémas ASCII obligent à clarifier la structure. 1) Architecture simple Ce schéma rappelle un principe fondamental : l’état alimente le rendu, pas l’inverse. 2) Boucle d’événements Ce flux est un invariant. Si vous le cassez, les bugs de rendu se multiplient. 3) Viewport et curseur Ce schéma montre pourquoi le viewport est indispensable : il découple la logique d’édition de la taille du terminal. 4) Barre de statut La barre doit être courte, stable, et informative. Elle est l’interface de confiance. 5) Rendu plein écran Ce rendu donne au lecteur une image mentale de ce qu’il doit obtenir. Un bon éditeur se comprend visuellement, même dans un manuel. 6) Flux d’édition C’est la chaîne la plus importante. Si elle est claire, l’éditeur est robuste. 7) Mode raw (idéal) Le mode raw n’est pas une fonctionnalité décorative : c’est un contrat avec le terminal. Il faut toujours garantir même en cas d’erreur. **À retenir** Gardez la règle simple et visible. Une erreur doit être actionnable, pas silencieuse. La lisibilité est une fonctionnalité. Synthèse Ces sections avancées ne sont pas « pour plus tard ». Elles vous donnent une vision de ce qu’un éditeur “sérieux” implique. Même si vous ne les implémentez pas toutes, le simple fait de les comprendre vous aide à écrire un code plus sûr aujourd’hui. Chapitre avancé : fonctionnalités d’éditeur moderne Cette section prolonge l’éditeur minimal vers un éditeur “confortable”. L’objectif n’est pas de tout implémenter, mais de comprendre l’architecture qui rend ces fonctionnalités possibles. La règle reste la même : état clair, rendu clair, et entrée claire. 1) Undo multi‑niveau Un undo simple est utile, mais un undo multi‑niveau est une question de confiance. Pour l’implémenter proprement, il faut stocker des “actions inverses” plutôt que des snapshots complets. **Principe** : chaque action (ins, del, replace) pousse une entrée dans une pile . L’entrée décrit comment revenir en arrière. ⇒ action inverse : . ⇒ action inverse : . ⇒ action inverse : . Vous gardez une pile pour et une pile pour . Chaque nouvelle action vide la pile . Ce modèle est simple, stable, et prévisible. 2) Recherche incrémentale La recherche incrémentale ne doit pas être “magique”. Elle doit simplement surligner la première occurrence pendant que l’utilisateur tape. Cela implique : une zone d’entrée pour le terme,. une fonction ,. un curseur qui saute au prochain match. La recherche incrémentale est un excellent test de votre séparation état/rendu. Si l’état est clair, la recherche se branche naturellement. 3) Remplacement (replace) Un replace global est dangereux. Un replace interactif est un contrat. La version simple : chercher la prochaine occurrence,. demander pour remplacer,. continuer. Cela paraît lent, mais c’est la version la plus sûre. Le but est de ne jamais surprendre l’utilisateur. 4) Sélection et mode visuel Une sélection terminale est d’abord un intervalle . Vous n’avez pas besoin d’un mode visuel compliqué pour commencer. Le rendu peut simplement inverser les couleurs ou entourer la zone. L’important n’est pas l’effet graphique, mais la cohérence des indices. 5) Sauts et navigation Ajoutez et . Ces deux commandes augmentent énormément la productivité. Elles doivent être sûres : si la ligne n’existe pas, on ne bouge pas, on avertit. 6) Format et indentation Un éditeur de code gagne instantanément en crédibilité si l’indentation est stable. Même un simple “auto‑indent” qui copie l’indentation de la ligne précédente améliore l’expérience. 7) Thèmes et couleurs Les couleurs sont utiles, mais non essentielles. Commencez par la clarté : un fond, un texte, une barre de statut. La colorisation syntaxique est un bonus, pas un prérequis. **À retenir** Gardez la règle simple et visible. Une erreur doit être actionnable, pas silencieuse. La lisibilité est une fonctionnalité. Chapitre avancé : interop C/C++ pour un moteur externe Ici, nous abordons un scénario réaliste : vous voulez un rendu plus riche ou un handling clavier robuste. Vous pouvez appeler une petite bibliothèque C/C++ qui gère les détails du terminal. L’interop est un contrat, pas une magie. 1) Définir une API minimale Vous ne voulez pas exposer toute une bibliothèque. Vous voulez une surface minimale : . . . . Cette API est suffisante pour brancher un moteur externe sans détruire la lisibilité de votre code Vitte. 2) Externs côté Vitte Ces signatures sont volontairement simples. Elles évitent des structures complexes et gardent l’interface stable. 3) Adaptation côté C Côté C/C++, vous implémentez les fonctions exportées. Le point crucial : vous devez garantir la stabilité des conventions d’appel et la gestion des erreurs. 4) Flux d’utilisation . boucle d’événements : → → . même en cas d’erreur. La règle est stricte : ne jamais laisser le terminal dans un état incohérent. 5) Gestion des erreurs Chaque appel externe doit être vérifié. Un retour doit conduire à un message clair et à un shutdown propre. L’interop n’est pas un endroit où l’on improvise. 6) Documentation de l’ABI Documentez votre ABI dans le livre. Même une page suffit : types, conventions, valeurs de retour. Sans cela, l’interop devient un piège. **À retenir** Gardez la règle simple et visible. Une erreur doit être actionnable, pas silencieuse. La lisibilité est une fonctionnalité. Résumé des extensions Vous avez maintenant une feuille de route pour transformer un éditeur minimal en éditeur sérieux : undo, recherche, replace, navigation, et éventuellement un moteur externe. Le cœur reste le même : une architecture claire qui respecte l’utilisateur. Glossaire de l’éditeur **Buffer** Zone mémoire qui contient les lignes d’un fichier. Dans un éditeur, le buffer est la vérité. Si le buffer est cohérent, l’éditeur est cohérent. **Cursor (curseur)** Position logique dans le texte, exprimée en ligne/colonne. Ce n’est pas un symbole graphique : c’est un état. **Viewport** Fenêtre sur le buffer. Le viewport décrit la portion visible à l’écran. Sans viewport, le défilement devient un bug permanent. **Dirty flag** Indicateur qui signifie “modifié depuis la dernière sauvegarde”. C’est un contrat moral : si est vrai, l’éditeur doit protéger l’utilisateur. **Render** Processus qui transforme l’état en affichage. Un bon rendu est déterministe : même état, même écran. **Raw mode** Mode terminal où l’entrée est lue caractère par caractère, sans interprétation. Indispensable pour un éditeur interactif. **Event loop** Boucle qui lit les entrées, met à jour l’état, puis redessine. C’est le cœur de tout éditeur moderne. **Undo stack** Pile d’actions inverses qui permet de revenir en arrière. Elle évite les snapshots coûteux et rend l’undo prévisible. **Redo stack** Pile d’actions annulées que l’on peut réappliquer. Elle se vide dès qu’une nouvelle action est commise. **Atomic save** Stratégie de sauvegarde qui écrit dans un fichier temporaire puis remplace l’original. Elle réduit drastiquement le risque de corruption. **Journal** Fichier qui enregistre les opérations d’édition. En cas de crash, il sert de base pour récupérer les changements. **Status bar** Ligne d’information stable qui indique le fichier, la taille, et l’état dirty. C’est une promesse de clarté. Conception détaillée (architecture opérationnelle) Cette section transforme le projet en un plan d’implémentation concret. L’objectif est de rendre l’éditeur réellement opérationnel, en précisant les responsabilités, les modules, et l’outillage nécessaire. Nous allons introduire des extraits en Vitte, mais aussi des exemples en C pour la partie terminal bas niveau. Ce mélange n’est pas un gadget : c’est la manière la plus réaliste de construire un éditeur robuste aujourd’hui. 1) Découpage en modules Un éditeur opérationnel devient vite un monolithe. Évitez ce piège dès le début avec un découpage clair : : structures d’état ( , , ). : opérations sur les lignes (insert, delete, replace). : parsing et exécution des commandes. : rendu (ligne par ligne ou plein écran). : chargement/sauvegarde, conversion, erreurs. : boucle principale. Ce découpage est un contrat de lecture. Chaque fichier a un rôle. Quand vous revenez dans six mois, vous savez où chercher. 2) Interfaces minimales Chaque module expose une interface étroite : expose , , . expose , , . expose et . expose et . expose et . Le but est de rendre les dépendances visibles et limitées. 3) Format de fichier Le format est texte brut. Ne tentez pas d’inventer un format “intelligent”. L’éditeur doit rester compatible avec , , , et tous les outils Unix. C’est une stratégie de compatibilité, pas une contrainte. 4) Table de commandes Pour éviter une chaîne infinie de , utilisez une table de dispatch. Même si la stdlib n’a pas de map, une liste de paires suffit. Ce modèle vous force à écrire des commandes petites et testables. Rendu opérationnel (version ligne par ligne) Cette version fonctionne sans mode raw. Elle est simple, mais utile. C’est une étape réaliste pour obtenir un outil stable. Principe Vous affichez un prompt . L’utilisateur tape une commande. Vous exécutez. Vous réaffichez. Ce modèle est similaire à un REPL. Il n’est pas élégant, mais il est robuste. Rendu opérationnel (version plein écran, API idéale + C) Le mode raw nécessite des appels bas niveau. Voici un exemple en C qui met le terminal en mode raw et lit une touche. Ce code est volontairement court et pragmatique. Fichier C : Ce code active un mode raw minimal, lit un caractère, et écrit un buffer. Il est suffisant pour un prototype. Les touches spéciales (flèches, etc.) nécessitent une couche d’interprétation supplémentaire. Binding côté Vitte La frontière est claire. Le code Vitte ne manipule pas la . Il parle à un petit moteur externe. Boucle “raw” en Vitte (concept) Ce pseudo‑code montre la séparation : entrée → état → rendu. C’est l’architecture qui tient la route. Build opérationnel (exemple minimal) Un éditeur multi‑langages a besoin d’un pipeline simple. Voici un exemple conceptuel : Adaptez ce pipeline à votre système. Le point important est la clarté de la chaîne de build : vous savez ce qui est compilé, et dans quel ordre. Tests opérationnels (manuel + script) En plus des scénarios manuels décrits plus haut, vous pouvez écrire un script de test simple qui envoie des commandes au programme. Exemple de script (shell) Ce test ne remplace pas un framework, mais il vérifie un flux critique en un seul appel. C’est particulièrement utile avant une démo. Conclusion : rendre un éditeur “réel” Un éditeur opérationnel ne dépend pas de 10 000 fonctionnalités. Il dépend d’un petit nombre de règles strictes : séparation des responsabilités, sauvegarde sûre, et feedback clair. En ajoutant un petit module C pour le terminal, vous obtenez une base technique solide, sans sacrifier la lisibilité du code Vitte. Build complet (Makefile Vitte + C) Un éditeur opérationnel qui mélange Vitte et C doit avoir un build reproductible. Le Makefile suivant est volontairement explicite : il montre chaque étape de compilation et d’édition de liens. La clarté est une fonctionnalité. Exemple de Makefile Ce Makefile est minimal, mais il est lisible et stable. Vous pouvez l’étendre avec des cibles , , ou , mais gardez le même niveau de clarté. Makefile complet (Vitte + C + ) Voici une version plus complète qui compile le module C, le code Vitte, et ajoute une cible pour valider la présence du fichier . Ce Makefile reste simple, mais il couvre la chaîne complète. Il est suffisamment clair pour être adapté à un vrai projet. Mini spec (contrats + validation) Cette mini‑spec décrit ce que l’éditeur attend de ` theme light dark status_bar key_save key_quit editor theme = light status_bar = true key_save = ctrl+s key_quit = ctrl+q error: editor.theme must be light|dark error: editor.key_save must be non-empty string warning: unknown key editor.color theme fatal: invalid config: editor.theme must be light|dark --strict-config`."
  },
  {
    "title": "'27. Annexes : grammaire (description narrative)'",
    "url": "/book/27-grammaire/",
    "text": "27. Annexes : grammaire (description narrative) Cette annexe décrit la syntaxe de Vitte en prose continue, avec des exemples courts. Elle sert de référence exhaustive, mais dans un style lisible. Chaque section explique le rôle de la construction, sa forme, et la logique qui la justifie. L’objectif n’est pas de fournir une grammaire formelle, mais un guide qui aide à écrire du code clair et stable. Structure générale d’un fichier Un fichier Vitte est une suite d’éléments déclaratifs et d’éléments exécutables. La manière dont ces éléments sont ordonnés n’est pas seulement une question esthétique, elle définit la lisibilité du fichier. En pratique, un fichier lisible commence par son identité, puis ses dépendances, puis ses déclarations, et enfin ses procédures. Cette hiérarchie évite d’obliger le lecteur à faire des allers‑retours dans le fichier. Une structure simple rend la compréhension immédiate. Lorsque le fichier grandit, cette discipline devient un gain réel, car elle transforme un bloc de texte en une architecture visible. Modules et espace de noms La déclaration associe le fichier à un chemin de module. Ce chemin est une adresse, pas un décor. Il doit rester cohérent avec l’arborescence réelle, sinon l’architecture devient un puzzle inutile. Le module est un contrat de visibilité, et ce contrat a plus de valeur que n’importe quelle optimisation de packaging. Un bon simplifie tout le reste, parce qu’il rend les imports cohérents et évite les collisions de noms. Un mauvais force les exceptions et fragilise la maintenance. Imports et visibilité L’import rend des symboles visibles dans le fichier courant. L’import est réservé aux modules locaux, plus explicite et plus contrôlé. L’export rend un symbole disponible pour les autres modules. Ces mots‑clés ne sont pas décoratifs, ils incarnent une politique de visibilité. Il est important de garder les imports ciblés. Un import trop large rend les dépendances invisibles et augmente le couplage. À long terme, la clarté des imports est un gain de maintenance. Constantes Une constante ( ) exprime une valeur immuable et stable. Elle doit être typée, nommée, et pensée comme un contrat. Les constantes remplacent les valeurs magiques et rendent l’intention lisible. Si une valeur change souvent, ce n’est pas une constante. Utiliser sans discipline est une source de bugs subtils. Alias de types Un alias de type ( ) donne un nom à une intention. Il n’ajoute pas de coût d’exécution, mais il augmente la lisibilité. Un alias comme est plus lisible qu’un nu, et cette différence devient cruciale à grande échelle. Structures ( ) Une structure regroupe des champs cohérents. Elle doit correspondre à une réalité stable du domaine. Un qui change en permanence indique un modèle flou. Chaque champ doit porter un invariant, et la structure doit être suffisamment petite pour être comprise rapidement. Variants ( ) Un exprime un choix fini. C’est l’outil principal pour modéliser des états exclusifs. Remplacer un par des booléens multiples est un anti‑pattern classique, car cela crée des combinaisons invalides. Un bien choisi clarifie la logique. Il impose un traitement explicite des cas, ce qui réduit les bugs. Procédures ( ) Une procédure est un contrat. Elle doit être courte, explicite, et claire sur ses effets. Une signature lisible est une promesse de stabilité. Si une procédure nécessite un commentaire pour être comprise, c’est un signal qu’elle est trop complexe. Entrée ( ) Le point d’entrée relie votre code à la plateforme. La forme rend explicite cette liaison. Cette explicitation est un choix de design : elle évite l’ambiguïté et prépare le code à plusieurs cibles. Macros ( ) Les macros sont puissantes et dangereuses. Elles doivent rester petites et documentées. Une macro qui cache une logique complexe devient un piège. Si une fonction suffit, il faut préférer une fonction. Instructions de base Les instructions , , , et constituent le cœur du langage. déclare une variable. rend explicite la mutation. termine une procédure. est une forme de retour explicite utilisée fréquemment dans la stdlib pour rendre le flux de valeur visible. Expressions et opérateurs Les expressions utilisent une grammaire classique, mais leur lisibilité doit être surveillée. Une expression dense devient rapidement opaque. La règle pragmatique est simple : si vous devez relire une expression, elle est trop dense et mérite un nom intermédiaire. Contrôle de flux Le contrôle de flux doit être lisible à voix haute. Les blocs explicites sont obligatoires pour éviter les ambiguïtés. , , , , et forment la grammaire du flux. Une boucle claire vaut mieux qu’une boucle compacte et obscure. et exprime des alternatives explicites. Il doit être complet, et inclure un cas par défaut avec . est utile pour tester un variant et garder le flux lisible. Ces constructions existent pour rendre les cas visibles, pas pour économiser des lignes. Littéraux Les littéraux sont simples mais portent des décisions implicites. Utilisez des constantes pour éviter les valeurs magiques. Les littéraux acceptés sont les entiers, flottants, hexadécimaux, chaînes, et booléens. Attributs et ABI Les attributs modifient la compilation ou la liaison. Ils doivent rester rares, visibles, et documentés. L’attribut marque une frontière ABI. Cette frontière est un contrat binaire qui doit être documenté rigoureusement. Lisibilité, style, et stabilité La grammaire dit ce qui est valide, mais le style dit ce qui est lisible. La lisibilité est un choix, pas un accident. Un code lisible réduit les erreurs et accélère la maintenance. Un code illisible est un coût durable. La stabilité d’un projet dépend de la stabilité de ses conventions. Quand un projet évolue, les conventions sont ce qui maintient l’unité. Si les conventions changent à chaque fichier, la syntaxe reste correcte, mais le projet devient illisible. Diagnostics, erreurs fréquentes, et bonnes pratiques Les diagnostics doivent être lus comme des guides. Un message “expected ” indique un bloc manquant. Un “unexpected token” indique presque toujours un mot‑clé manquant ou un ordre incorrect. Ces erreurs ne sont pas des punitions, elles sont des indications de forme. Les erreurs les plus fréquentes viennent de l’oubli des blocs, de l’usage de sur des variables non déclarées, de incomplets, ou d’imports incorrects. Ces erreurs sont évitables par des conventions simples et une discipline d’écriture régulière. Exemple complet annoté Un exemple complet est plus utile qu’une centaine de règles isolées. Le fichier suivant illustre une structure lisible : module déclaré, imports ciblés, types clairs, procédure courte. Cet exemple est valide et lisible, parce que chaque élément est explicitement déclaré et que les dépendances sont visibles. Résumé express La grammaire de Vitte est conçue pour rendre les intentions explicites. définit le module, / gèrent la visibilité, et définissent les données, et définissent l’exécution. Les blocs explicites et les mutations visibles ( ) sont des choix de lisibilité. En respectant ces formes, vous obtenez un code stable, transmissible, et facile à relire."
  },
  {
    "title": "'28. Annexes : conventions'",
    "url": "/book/28-conventions/",
    "text": "28. Annexes : conventions Les conventions sont le ciment des projets partagés. Elles ne remplacent pas la technique, mais elles évitent beaucoup de frictions. Un projet qui change de style à chaque fichier devient illisible. Les conventions sont un pacte implicite entre les membres d’une équipe, et ce pacte doit être assez simple pour être respecté au quotidien. Ce chapitre propose un ensemble de règles simples, pragmatiques, et cohérentes avec le reste du livre. Elles ne sont pas “parfaites”, mais elles sont stables. La stabilité est ce qui rend un code transmissible, surtout quand l’équipe change ou que le projet traverse plusieurs années. 1) Nommage 1.1 Conventions de forme La règle de base est simple et visible. Utilisez pour les fonctions et les variables, et pour les et les . Cette distinction permet au lecteur de reconnaître immédiatement la nature d’un symbole, sans devoir scanner l’ensemble du fichier. Une convention de forme est un gain cognitif automatique. 1.2 Noms d’intention vs noms mécaniques Un nom d’intention exprime pourquoi la chose existe, pas comment elle est implémentée. Un nom mécanique décrit l’action brute, ce qui le rend fragile dès que l’implémentation change. Les noms d’intention sont donc préférables, parce qu’ils résistent aux refactors et qu’ils restent lisibles quand le code évolue. Un nom comme ne dit rien. Un nom comme raconte un comportement précis, même si l’algorithme interne change. L’objectif n’est pas d’être verbeux, mais d’être fidèle à l’intention. 2) Imports 2.1 Ordre recommandé L’ordre des imports doit être stable dans chaque fichier. Placez d’abord si le fichier définit un module, puis les , ensuite les , puis les déclarations ( , , , , ). Cet ordre crée un en‑tête lisible et prévisible. Il permet de comprendre la “surface” du fichier avant d’entrer dans la logique. 2.2 Limiter les imports globaux Importer un module entier “au cas où” crée des dépendances implicites. Préférez des imports ciblés qui rendent la dépendance visible. Un import clair aujourd’hui est une heure gagnée demain. 3) Modules 3.1 Une responsabilité par module Un module doit faire une seule chose. C’est la règle la plus simple et la plus efficace pour garder un code lisible. Si un module a plusieurs responsabilités, il devient un point de friction et de confusion. 3.2 Éviter les modules “fourre‑tout” Un module qui contient “un peu de tout” devient rapidement un lieu de dettes techniques. S’il dépasse sa responsabilité, scindez‑le tôt. Plus vous attendez, plus la scission devient coûteuse. 4) Tests 4.1 Nommage Les tests doivent être retrouvés en quelques secondes. Utilisez des noms explicites comme , , . Le but n’est pas l’esthétique, mais la rapidité d’accès. 4.2 Guide d’écriture de tests Un test doit être court, précis, et non‑fragile. S’il échoue pour des raisons non liées à son objectif, il est mal écrit. Un test fiable est un test qui raconte une histoire simple, avec un début et une fin claire. 5) Erreurs et diagnostics Les messages d’erreur doivent être courts et actionnables. Un bon message dit quoi faire, pas seulement ce qui est cassé. “error: failed” est inutile, parce qu’il ne guide aucune action. Un message comme “error: cannot open config file (missing path)” indique immédiatement ce qu’il faut vérifier. 6) Commits et PR Les règles de base sont simples : des commits petits, un message clair, et aucun mélange refactor/feature. Cela rend les PR relisibles et évite les conflits. Une PR claire coûte moins cher qu’une PR parfaite. 7) Configuration et outillage 7.1 Standardiser avec un Makefile Un Makefile explicite rend les builds reproductibles. Il doit décrire les cibles essentielles, comme , et . Un build explicite est plus facile à diagnostiquer qu’un script “magique”. 7.2 Configuration non triviale Si votre projet a une configuration non triviale, utilisez un format stable et documenté, et décrivez‑le clairement. Un format stable évite les fichiers “magiques” et réduit le nombre de surprises en production. 7.3 Éviter les scripts “magiques” Un script qui fait “trop de choses” sans documentation est un bug en attente. Si un script existe, il doit être décrit et justifié. Le coût d’une documentation courte est faible, le coût d’un script opaque est énorme. 8) Style Le style n’est pas cosmétique. Il réduit les erreurs en rendant les intentions visibles. Une ligne doit exprimer une seule idée, et toute mutation doit être explicite via . Ce sont des règles simples qui augmentent la clarté. 9) Checklist rapide Avant de valider un fichier, vérifiez mentalement les points suivants : les noms respectent‑ils ou selon leur nature, les imports suivent‑ils l’ordre recommandé, le module a‑t‑il une responsabilité claire, les tests sont‑ils courts et explicites, les erreurs sont‑elles actionnables, les commits sont‑ils petits et clairs, et le build est‑il documenté. Une checklist courte évite des retours coûteux. Exemples avant/après (noms, imports, erreurs) Cette section illustre la différence entre une convention appliquée et une convention ignorée. Les exemples sont courts, mais ils rendent la règle tangible. Nommage Avant, un nom comme ne dit rien. Après, un nom comme décrit une intention claire et stable. Cette différence est plus importante que la différence d’algorithme. Imports Avant, des imports larges comme masquent les dépendances réelles. Après, des imports ciblés rendent chaque dépendance visible et réduisent l’ambiguïté. L’ordre puis puis déclarations crée un en‑tête lisible. Erreurs Avant, un message générique comme “error: failed” ne dit rien. Après, “error: cannot open config file (missing path)” donne une action implicite. Un bon diagnostic est un raccourci vers la solution. Mini glossaire des conventions Les noms d’intention sont des noms qui expriment le rôle, comme , et non des noms mécaniques comme . Un module responsable est un module qui fait une seule chose et la fait bien. Un test non‑fragile échoue seulement quand l’intention est brisée, pas quand le format change. Un commit atomique contient une seule idée ou un seul changement logique. Encadré : Conventions d’équipe (adoption sans friction) Une convention fonctionne si elle est adoptée, pas si elle est parfaite. Pour l’adoption, écrivez une règle courte, ajoutez un exemple bon/mauvais, appliquez‑la d’abord aux nouveaux fichiers, mesurez l’effet, puis étendez progressivement. L’objectif n’est pas de “forcer”, mais d’aligner. Conventions quand on grandit Quand un projet grossit, les règles doivent évoluer. Ajoutez des sous‑modules quand un module dépasse une responsabilité claire, quand ses imports deviennent trop lourds, ou quand plusieurs personnes modifient régulièrement la même zone. Splitter un module devient nécessaire quand un fichier dépasse un seuil lisible, quand plusieurs sujets cohabitent, ou quand la relecture devient lente et incertaine. Anti‑conventions (pièges courants) Ces pratiques semblent pratiques à court terme, mais détruisent la lisibilité. Importer un module entier “au cas où” rend les dépendances invisibles. Nommer une variable partout rend le code incompréhensible. Mélanger refactor et feature dans un même commit rend les PR illisibles. Écrire un script magique sans documentation crée une dette immédiate. Centraliser trop tôt dans un module “utils” crée un monstre difficile à découper."
  },
  {
    "title": "'29. Annexes : style de code'",
    "url": "/book/29-style/",
    "text": "29. Annexes : style de code Le style de code n’est pas une religion. Il sert à rendre le code lisible et à réduire l’effort cognitif. Un style pragmatique Une ligne, une idée. Des noms explicites. Des fonctions courtes. Le style comme outil Le style n’est pas là pour « faire joli ». Il est là pour rendre le code plus facile à relire, à comprendre, et à maintenir."
  },
  {
    "title": "'30. Annexes : FAQ'",
    "url": "/book/30-faq/",
    "text": "30. Annexes : FAQ Pourquoi Vitte ? Parce qu’un code bas niveau peut être clair, stable, et agréable à relire. Vitte est‑il un langage « safe » ? Vitte privilégie l’explicite. Il ne promet pas une sécurité magique, mais il vous donne les outils pour écrire un code robuste. Comment contribuer ? Commencez par un test, un bug report, ou un petit patch documenté. Où trouver la doc ? Le livre est votre guide principal, et les diagnostics du compilateur sont un second guide. Si quelque chose vous semble flou, commencez par réduire le cas minimal."
  },
  {
    "title": "Vitte CLI",
    "url": "/pages/cli/",
    "text": "Vitte CLI Usage: Commands (recommended): - Show help and common tasks - Create a minimal project scaffold - Explain a diagnostic (e.g. E0001) - Check toolchain prerequisites - Parse only (no backend) - Parse + resolve only - Emit C++ only (no native compile) - Full build (default) Options: - Language for diagnostics (e.g. en, fr). Defaults to , then . - Explain a diagnostic (e.g. E0001). - Emit C++ to stdout (implies ). - Emit a native object file ( ). - Enable reproducible object output flags. - Enforce strict deterministic IR lowering order. - Parse + load modules (no resolve/lowering). - Suppress parse-only informational logs. - Diagnostics include stable error codes (e.g. ). Examples: Error Codes: - Diagnostics use stable codes like . These codes are defined in . - The localization files can translate by code (preferred) or by message key. Stdlib: - See for standard library modules and examples. Legacy flags (still supported): - - - - - - Notes: - Commands set a default mode, but explicit flags still override. - For strict parsing, use ."
  },
  {
    "title": "Vitte Errors",
    "url": "/pages/errors/",
    "text": "Vitte Errors This page documents diagnostic codes and common fixes. E0001: expected identifier **Summary** The parser expected a name for something (variable, type, module, etc.). **Fix** Add a valid identifier where the error points (letters, digits, and after the first character). **Example** E0005: expected 'end' **Summary** A block was opened but not closed with or . **Fix** Add the missing terminator for the construct you opened (for example: for procs, for form/pick blocks). **Example** E0002: expected expression **Summary** The parser expected an expression at this location. **Fix** Provide a value, call, or block expression (e.g., , , , ). **Example** E0004: expected type **Summary** The parser expected a type name. **Fix** Use a built-in type (int, bool, string) or a named type (e.g., ). **Example** E0013: unknown identifier **Summary** A referenced name was not found in the current scope. **Fix** Check spelling, or import it from a module with or . **Example** E0018: extern proc cannot have a body **Summary** An extern procedure cannot define a body. **Fix** Remove the body or drop if you want to implement it here. **Example** E0019: proc requires a body unless marked #[extern] **Summary** A procedure must have a body unless marked . **Fix** Add a body with or mark it if it is provided by the runtime. **Example** E0020: type alias requires a target type **Summary** A type alias must specify a target type. **Fix** Provide the right-hand side of the alias. **Example** E0024: select requires at least one when branch **Summary** A select statement needs at least one when branch. **Fix** Add a clause (and optionally ). **Example** E0026: unexpected HIR stmt kind **Summary** The compiler encountered an unexpected HIR statement kind. **Fix** This is likely a compiler bug; try a simpler statement and report it. **Example** E0027: unexpected HIR pattern kind **Summary** The compiler encountered an unexpected HIR pattern kind. **Fix** This is likely a compiler bug; try a simpler pattern and report it. **Example** E0028: unexpected HIR decl kind **Summary** The compiler encountered an unexpected HIR declaration kind. **Fix** This is likely a compiler bug; try a simpler declaration and report it. **Example** E0025: select branch must be a when statement **Summary** Each select branch must be a statement. **Fix** Replace the branch with a pattern (or use ). **Example** E0003: expected pattern **Summary** The parser expected a pattern. **Fix** Use a pattern like an identifier or constructor (e.g., ). **Example** E0006: expected proc after attribute **Summary** An attribute must be followed by a proc declaration. **Fix** Place the attribute directly above a proc. **Example** E0007: expected top-level declaration **Summary** The parser expected a top-level declaration. **Fix** Top-level items include , , , , , , , and . **Example** E0008: duplicate pattern binding **Summary** A pattern bound the same name more than once. **Fix** Use distinct names for each binding in the pattern. **Example** E0009: unknown type **Summary** A referenced type name was not found. **Fix** Check spelling or import the type with or . **Example** E0010: unknown generic base type **Summary** The base type of a generic was not found. **Fix** Check spelling or import the base type with or . **Example** E0011: generic type requires at least one argument **Summary** A generic type must include at least one argument. **Fix** Provide one or more type arguments inside . **Example** E0012: unsupported type **Summary** This type form is not supported yet. **Fix** Use a supported type (built-ins, named types, pointers, slices, proc types). **Example** E0014: invoke has no callee **Summary** An invocation is missing its callee. **Fix** Provide a function or proc name before the arguments. **Example** E0015: unsupported expression in HIR **Summary** This expression is not supported by the HIR lowering yet. **Fix** Rewrite the expression using supported constructs. **Example** E0016: unsupported pattern in HIR **Summary** This pattern is not supported by the HIR lowering yet. **Fix** Rewrite the pattern using supported constructs. **Example** E0017: unsupported statement in HIR **Summary** This statement is not supported by the HIR lowering yet. **Fix** Rewrite the statement using supported constructs. **Example** E0021: generic type requires at least one type argument **Summary** A generic type needs at least one type argument. **Fix** Provide type arguments inside . **Example** E0022: unexpected HIR type kind **Summary** The compiler encountered an unexpected HIR type kind. **Fix** This is likely a compiler bug; try a simpler type and report it. **Example** E0023: unexpected HIR expr kind **Summary** The compiler encountered an unexpected HIR expression kind. **Fix** This is likely a compiler bug; try a simpler expression and report it. **Example**"
  },
  {
    "title": "Stdlib",
    "url": "/pages/stdlib/",
    "text": "<<< stdlib.md Standard library modules (selected) >>> std/process Run a command and capture output. Notes: - captures stdout and captures stderr. std/os Platform helpers. std/regex Regex compilation + matching. std/fswatch Simple file watch (polling, last-write-time). std/metrics In-memory counters, gauges, and timers. std/async Synchronous task helpers (spawn runs immediately for now). std/db Simple key/value database (file-backed)."
  },
  {
    "title": "Grammar (Vitte 1.0)",
    "url": "/pages/grammar/",
    "text": "Grammar (Vitte 1.0) Source of truth: This directory splits the grammar into focused sections: - - - - - Operator precedence is documented in ."
  }
]